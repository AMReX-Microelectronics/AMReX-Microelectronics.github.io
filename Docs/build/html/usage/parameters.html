<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Input Parameters &mdash; MicroEleX 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css?v=0a3b3ea7" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=f2a433a1"></script>
        <script src="../_static/doctools.js?v=9a2dae69"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/design-tabs.js?v=36754332"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python (PICMI)" href="python.html" />
    <link rel="prev" title="Domain Decomposition" href="domain_decomposition.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            MicroEleX
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">INSTALLATION</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install/users.html">Users</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/cmake.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install/hpc.html">HPC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">USAGE</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="how_to_run.html">Run WarpX</a></li>
<li class="toctree-l1"><a class="reference internal" href="domain_decomposition.html">Domain Decomposition</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Input Parameters</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overall-simulation-parameters">Overall simulation parameters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#signal-handling">Signal Handling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-the-field-mesh">Setting up the field mesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="#domain-boundary-conditions">Domain Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#additional-pml-parameters">Additional PML parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#embedded-boundary-conditions">Embedded Boundary Conditions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#distribution-across-mpi-ranks-and-parallelization">Distribution across MPI ranks and parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#math-parser-and-user-defined-constants">Math parser and user-defined constants</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#warpx-constants">WarpX constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-defined-constants">User-defined constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coordinates">Coordinates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#particle-initialization">Particle initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#laser-initialization">Laser initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#external-fields">External fields</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#grid-initialization">Grid initialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applied-to-particles">Applied to Particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accelerator-lattice">Accelerator Lattice</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#collision-models">Collision models</a></li>
<li class="toctree-l2"><a class="reference internal" href="#numerics-and-algorithms">Numerics and algorithms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#time-step">Time step</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filtering">Filtering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#particle-push-charge-and-current-deposition-field-gathering">Particle push, charge and current deposition, field gathering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maxwell-solver">Maxwell solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maxwell-solver-psatd-method">Maxwell solver: PSATD method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maxwell-solver-macroscopic-media">Maxwell solver: macroscopic media</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grid-types-collocated-staggered-hybrid">Grid types (collocated, staggered, hybrid)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additional-parameters">Additional parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#diagnostics-and-output">Diagnostics and output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#in-situ-visualization">In-situ visualization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#full-diagnostics">Full Diagnostics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#backtransformed-diagnostics">BackTransformed Diagnostics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boundary-scraping-diagnostics">Boundary Scraping Diagnostics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reduced-diagnostics">Reduced Diagnostics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#lookup-tables-and-other-settings-for-qed-modules">Lookup tables and other settings for QED modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checkpoints-and-restart">Checkpoints and restart</a></li>
<li class="toctree-l2"><a class="reference internal" href="#intervals-parser">Intervals parser</a></li>
<li class="toctree-l2"><a class="reference internal" href="#solving-magnetization-using-llg-equation">Solving magnetization using LLG equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#testing-and-debugging">Testing and Debugging</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python (PICMI)</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DATA ANALYSIS</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/formats.html">Output formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/yt.html">yt-project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/openpmdviewer.html">openPMD-viewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/openpmdapi.html">openPMD-api</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/paraview.html">3D Visualization: ParaView</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/visit.html">3D Visualization: VisIt</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/visualpic.html">VisualPIC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/picviewer.html">PICViewer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/reduced_diags.html">Reduced diagnostics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dataanalysis/workflows.html">Workflows</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">EPILOGUE</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../acknowledgements.html">Funding and Acknowledgements</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MicroEleX</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Input Parameters</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/usage/parameters.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="input-parameters">
<span id="running-cpp-parameters"></span><h1>Input Parameters<a class="headerlink" href="#input-parameters" title="Link to this heading"></a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>WarpX input options are read via AMReX <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/Basics.html#parmparse">ParmParse</a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The AMReX parser (see <a class="reference internal" href="#running-cpp-parameters-parser"><span class="std std-ref">Math parser and user-defined constants</span></a>) is used for the right-hand-side of all input parameters that consist of one or more integers or floats, so expressions like <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.density_max</span> <span class="pre">=</span> <span class="pre">&quot;2.+1.&quot;</span></code> and/or using user-defined constants are accepted.</p>
</div>
<section id="overall-simulation-parameters">
<span id="running-cpp-parameters-overall"></span><h2>Overall simulation parameters<a class="headerlink" href="#overall-simulation-parameters" title="Link to this heading"></a></h2>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">authors</span></code> (<cite>string</cite>: e.g. <code class="docutils literal notranslate"><span class="pre">&quot;Jane</span> <span class="pre">Doe</span> <span class="pre">&lt;jane&#64;example.com&gt;,</span> <span class="pre">Jimmy</span> <span class="pre">Joe</span> <span class="pre">&lt;jimmy&#64;example.com&gt;&quot;</span></code>)</dt><dd><p>Authors of an input file / simulation setup.
When provided, this information is added as metadata to (openPMD) output files.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">max_step</span></code> (<cite>integer</cite>)</dt><dd><p>The number of PIC cycles to perform.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">stop_time</span></code> (<cite>float</cite>; in seconds)</dt><dd><p>The maximum physical time of the simulation. Can be provided instead of <code class="docutils literal notranslate"><span class="pre">max_step</span></code>. If both
<code class="docutils literal notranslate"><span class="pre">max_step</span></code> and <code class="docutils literal notranslate"><span class="pre">stop_time</span></code> are provided, both criteria are used and the simulation stops
when the first criterion is hit.</p>
<p>Note: in boosted-frame simulations, <code class="docutils literal notranslate"><span class="pre">stop_time</span></code> refers to the time in the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.used_inputs_file</span></code> (<cite>string</cite>; default: <code class="docutils literal notranslate"><span class="pre">warpx_used_inputs</span></code>)</dt><dd><p>Name of a file that WarpX writes to archive the used inputs.
The context of this file will contain an exact copy of all explicitly and implicitly used inputs parameters, including those <a class="reference internal" href="how_to_run.html#usage-run"><span class="std std-ref">extended and overwritten from the command line</span></a>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code> (<cite>float</cite>)</dt><dd><p>The Lorentz factor of the boosted frame in which the simulation is run.
(The corresponding Lorentz transformation is assumed to be along <code class="docutils literal notranslate"><span class="pre">warpx.boost_direction</span></code>.)</p>
<p>When using this parameter, the input parameters are interpreted as in the
lab-frame and automatically converted to the boosted frame.
(See the corresponding documentation of each input parameters for exceptions.)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.boost_direction</span></code> (string: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">z</span></code>)</dt><dd><p>The direction of the Lorentz-transform for boosted-frame simulations
(The direction <code class="docutils literal notranslate"><span class="pre">y</span></code> cannot be used in 2D simulations.)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.zmax_plasma_to_compute_max_step</span></code> (<cite>float</cite>) optional</dt><dd><p>Can be useful when running in a boosted frame. If specified, automatically
calculates the number of iterations required in the boosted frame for the
lower <cite>z</cite> end of the simulation domain to reach
<code class="docutils literal notranslate"><span class="pre">warpx.zmax_plasma_to_compute_max_step</span></code> (typically the plasma end,
given in the lab frame). The value of <code class="docutils literal notranslate"><span class="pre">max_step</span></code> is overwritten, and
printed to standard output. Currently only works if the Lorentz boost and
the moving window are along the z direction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.compute_max_step_from_btd</span></code> (<cite>integer</cite>; 0 by default) optional</dt><dd><p>Can be useful when computing back-transformed diagnostics.  If specified,
automatically calculates the number of iterations required in the boosted
frame for all back-transformed diagnostics to be completed. If <code class="docutils literal notranslate"><span class="pre">max_step</span></code>,
<code class="docutils literal notranslate"><span class="pre">stop_time</span></code>, or <code class="docutils literal notranslate"><span class="pre">warpx.zmax_plasma_to_compute_max_step</span></code> are not specified,
or the current values of <code class="docutils literal notranslate"><span class="pre">max_step</span></code> and/or <code class="docutils literal notranslate"><span class="pre">stop_time</span></code> are too low to fill
all BTD snapshots, the values of <code class="docutils literal notranslate"><span class="pre">max_step</span></code> and/or <code class="docutils literal notranslate"><span class="pre">stop_time</span></code> are
overwritten with the new values and printed to standard output.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.random_seed</span></code> (<cite>string</cite> or <cite>int</cite> &gt; 0) optional</dt><dd><p>If provided <code class="docutils literal notranslate"><span class="pre">warpx.random_seed</span> <span class="pre">=</span> <span class="pre">random</span></code>, the random seed will be determined
using <cite>std::random_device</cite> and <cite>std::clock()</cite>,
thus every simulation run produces different random numbers.
If provided <code class="docutils literal notranslate"><span class="pre">warpx.random_seed</span> <span class="pre">=</span> <span class="pre">n</span></code>, and it is required that <cite>n &gt; 0</cite>,
the random seed for each MPI rank is <cite>(mpi_rank+1) * n</cite>,
where <cite>mpi_rank</cite> starts from 0.
<cite>n = 1</cite> and <code class="docutils literal notranslate"><span class="pre">warpx.random_seed</span> <span class="pre">=</span> <span class="pre">default</span></code>
produce the default random seed.
Note that when GPU threading is used,
one should not expect to obtain the same random numbers,
even if a fixed <code class="docutils literal notranslate"><span class="pre">warpx.random_seed</span></code> is provided.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_electrostatic</span></code> (<cite>string</cite>) optional (default <cite>none</cite>)</dt><dd><p>Specifies the electrostatic mode. When turned on, instead of updating
the fields at each iteration with the full Maxwell equations, the fields
are recomputed at each iteration from the Poisson equation.
There is no limitation on the timestep in this case, but
electromagnetic effects (e.g. propagation of radiation, lasers, etc.)
are not captured. There are several options:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">labframe</span></code>: Poisson’s equation is solved in the lab frame with
the charge density of all species combined. More specifically, the code solves:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\nabla}^2 \phi = - \rho/\epsilon_0 \qquad \boldsymbol{E} = - \boldsymbol{\nabla}\phi\]</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">labframe-electromagnetostatic</span></code>: Poisson’s equation is solved in the lab frame with
the charge density of all species combined.  Additionally the 3-component vector potential
is solved in the Coulomb Gauge with the current density of all species combined
to include self magnetic fields. More specifically, the code solves:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol{\nabla}^2 \phi = - \rho/\epsilon_0 \qquad \boldsymbol{E} = - \boldsymbol{\nabla}\phi \\
\boldsymbol{\nabla}^2 \boldsymbol{A} = - \mu_0 \boldsymbol{j} \qquad \boldsymbol{B} = \boldsymbol{\nabla}\times\boldsymbol{A}\end{split}\]</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">relativistic</span></code>: Poisson’s equation is solved <strong>for each species</strong>
in their respective rest frame. The corresponding field
is mapped back to the simulation frame and will produce both E and B
fields. More specifically, in the simulation frame, this is equivalent to solving <strong>for each species</strong></p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\nabla}^2 - (\boldsymbol{\beta}\cdot\boldsymbol{\nabla})^2\phi = - \rho/\epsilon_0 \qquad
\boldsymbol{E} = -\boldsymbol{\nabla}\phi + \boldsymbol{\beta}(\boldsymbol{\beta} \cdot \boldsymbol{\nabla}\phi)
\qquad \boldsymbol{B} = -\frac{1}{c}\boldsymbol{\beta}\times\boldsymbol{\nabla}\phi\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\beta}\)</span> is the average (normalized) velocity of the considered species (which can be relativistic).
See e.g. <a class="reference external" href="https://doi.org/10.1063/1.2837054">Vay et al., Physics of Plasmas 15, 056701 (2008)</a> for more information.</p>
</li>
</ul>
<p>See the <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/LinearSolvers.html#">AMReX documentation</a>
for details of the MLMG solver (the default solver used with electrostatic
simulations). The default behavior of the code is to check whether there is
non-zero charge density in the system and if so force the MLMG solver to
use the solution max norm when checking convergence. If there is no charge
density, the MLMG solver will switch to using the initial guess max norm
error when evaluating convergence and an absolute error tolerance of
<span class="math notranslate nohighlight">\(10^{-6}\)</span> <span class="math notranslate nohighlight">\(\mathrm{V/m}^2\)</span> will be used (unless a different
non-zero value is specified by the user via
<code class="docutils literal notranslate"><span class="pre">warpx.self_fields_absolute_tolerance</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.self_fields_required_precision</span></code> (<cite>float</cite>, default: 1.e-11)</dt><dd><p>The relative precision with which the electrostatic space-charge fields should
be calculated. More specifically, the space-charge fields are
computed with an iterative Multi-Level Multi-Grid (MLMG) solver.
This solver can fail to reach the default precision within a reasonable time.
This only applies when warpx.do_electrostatic = labframe.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.self_fields_absolute_tolerance</span></code> (<cite>float</cite>, default: 0.0)</dt><dd><p>The absolute tolerance with which the space-charge fields should be
calculated in units of <span class="math notranslate nohighlight">\(\mathrm{V/m}^2\)</span>. More specifically, the acceptable
residual with which the solution can be considered converged. In general
this should be left as the default, but in cases where the simulation state
changes very little between steps it can occur that the initial guess for
the MLMG solver is so close to the converged value that it fails to improve
that solution sufficiently to reach the <code class="docutils literal notranslate"><span class="pre">self_fields_required_precision</span></code>
value.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.self_fields_max_iters</span></code> (<cite>integer</cite>, default: 200)</dt><dd><p>Maximum number of iterations used for MLMG solver for space-charge
fields calculation. In case if MLMG converges but fails to reach the desired
<code class="docutils literal notranslate"><span class="pre">self_fields_required_precision</span></code>, this parameter may be increased.
This only applies when warpx.do_electrostatic = labframe.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.self_fields_verbosity</span></code> (<cite>integer</cite>, default: 2)</dt><dd><p>The vebosity used for MLMG solver for space-charge fields calculation. Currently
MLMG solver looks for verbosity levels from 0-5. A higher number results in more
verbose output.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amrex.abort_on_out_of_gpu_memory</span></code>  (<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>; default is <code class="docutils literal notranslate"><span class="pre">1</span></code> for true)</dt><dd><p>When running on GPUs, memory that does not fit on the device will be automatically swapped to host memory when this option is set to <code class="docutils literal notranslate"><span class="pre">0</span></code>.
This will cause severe performance drops.
Note that even with this set to <code class="docutils literal notranslate"><span class="pre">1</span></code> WarpX will not catch all out-of-memory events yet when operating close to maximum device memory.
<a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/GPU.html#inputs-parameters">Please also see the documentation in AMReX</a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amrex.the_arena_is_managed</span></code>  (<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>; default is <code class="docutils literal notranslate"><span class="pre">0</span></code> for false)</dt><dd><p>When running on GPUs, device memory that is accessed from the host will automatically be transferred with managed memory.
This is useful for convenience during development, but has sometimes severe performance and memory footprint implications if relied on (and sometimes vendor bugs).
For all regular WarpX operations, we therefore do explicit memory transfers without the need for managed memory and thus changed the AMReX default to false.
<a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/GPU.html#inputs-parameters">Please also see the documentation in AMReX</a>.</p>
</dd>
</dl>
</li>
</ul>
<section id="signal-handling">
<h3>Signal Handling<a class="headerlink" href="#signal-handling" title="Link to this heading"></a></h3>
<p>WarpX can handle Unix (Linux/macOS) <a class="reference external" href="https://en.wikipedia.org/wiki/Signal_(IPC)">process signals</a>.
This can be useful to configure jobs on HPC and cloud systems to shut down cleanly when they are close to reaching their allocated walltime or to steer the simulation behavior interactively.</p>
<p>Allowed signal names are documented in the <a class="reference external" href="https://en.cppreference.com/w/cpp/utility/program/SIG_types">C++ standard</a> and <a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html">POSIX</a>.
We follow the same naming, but remove the <code class="docutils literal notranslate"><span class="pre">SIG</span></code> prefix, e.g., the WarpX signal configuration name for <code class="docutils literal notranslate"><span class="pre">SIGINT</span></code> is <code class="docutils literal notranslate"><span class="pre">INT</span></code>.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.break_signals</span></code> (array of <cite>string</cite>, separated by spaces) optional</dt><dd><p>A list of signal names or numbers that the simulation should
handle by cleanly terminating at the next timestep</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.checkpoint_signals</span></code> (array of <cite>string</cite>, separated by spaces) optional</dt><dd><p>A list of signal names or numbers that the simulation should
handle by outputting a checkpoint at the next timestep. A
diagnostic of type <cite>checkpoint</cite> must be configured.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Certain signals are only available on specific platforms, please see the links above for details.
Typically supported on Linux and macOS are <code class="docutils literal notranslate"><span class="pre">HUP</span></code>, <code class="docutils literal notranslate"><span class="pre">INT</span></code>, <code class="docutils literal notranslate"><span class="pre">QUIT</span></code>, <code class="docutils literal notranslate"><span class="pre">ABRT</span></code>, <code class="docutils literal notranslate"><span class="pre">USR1</span></code>, <code class="docutils literal notranslate"><span class="pre">USR2</span></code>, <code class="docutils literal notranslate"><span class="pre">TERM</span></code>, <code class="docutils literal notranslate"><span class="pre">TSTP</span></code>, <code class="docutils literal notranslate"><span class="pre">URG</span></code>, and <code class="docutils literal notranslate"><span class="pre">IO</span></code> among others.</p>
<p>Signals to think about twice before overwriting in <em>interactive simulations</em>:
Note that <code class="docutils literal notranslate"><span class="pre">INT</span></code> (interupt) is the signal that <code class="docutils literal notranslate"><span class="pre">Ctrl+C</span></code> sends on the terminal, which most people use to abort a process; once overwritten you need to abort interactive jobs with, e.g., <code class="docutils literal notranslate"><span class="pre">Ctrl+\</span></code> (<code class="docutils literal notranslate"><span class="pre">QUIT</span></code>) or sending the <code class="docutils literal notranslate"><span class="pre">KILL</span></code> signal.
The <code class="docutils literal notranslate"><span class="pre">TSTP</span></code> (terminal stop) command is sent interactively from <code class="docutils literal notranslate"><span class="pre">Ctrl+Z</span></code> to temporarily send a process to sleep (until send in the background with commands such as <code class="docutils literal notranslate"><span class="pre">bg</span></code> or continued with <code class="docutils literal notranslate"><span class="pre">fg</span></code>), overwriting it would thus disable that functionality.
The signals <code class="docutils literal notranslate"><span class="pre">KILL</span></code> and <code class="docutils literal notranslate"><span class="pre">STOP</span></code> cannot be used.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">FPE</span></code> signal should not be overwritten in WarpX, as it is <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/Debugging.html#breaking-into-debuggers">controlled by AMReX</a> for <a class="reference internal" href="workflows/debugging.html#debugging-warpx"><span class="std std-ref">debug workflows that catch invalid floating-point operations</span></a>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>For example, the following logic can be added to <a class="reference external" href="https://docs.gwdg.de/doku.php?id=en:services:application_services:high_performance_computing:running_jobs_slurm:signals">Slurm batch scripts</a> (<a class="reference external" href="https://en.wikipedia.org/wiki/Signal_(IPC)#Default_action">signal name to number mapping here</a>) to gracefully shut down 6 min prior to walltime.
If you have a checkpoint diagnostics in your inputs file, this automatically will write a checkpoint due to the default <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.dump_last_timestep</span> <span class="pre">=</span> <span class="pre">1</span></code> option in WarpX.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#SBATCH --signal=B:1@360</span>

srun<span class="w"> </span>...<span class="w">                   </span><span class="se">\</span>
<span class="w">  </span>warpx.break_signals<span class="o">=</span>HUP<span class="w">  </span><span class="se">\</span>
<span class="w">  </span>&gt;<span class="w"> </span>output.txt
</pre></div>
</div>
<p>For <a class="reference external" href="https://www.ibm.com/docs/en/spectrum-lsf/10.1.0?topic=options-wa">LSF batch systems</a>, the equivalent job script lines are:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#BSUB -wa &#39;HUP&#39; -wt &#39;6&#39;</span>

jsrun<span class="w"> </span>...<span class="w">                  </span><span class="se">\</span>
<span class="w">  </span>warpx.break_signals<span class="o">=</span>HUP<span class="w">  </span><span class="se">\</span>
<span class="w">  </span>&gt;<span class="w"> </span>output.txt
</pre></div>
</div>
</div>
</section>
</section>
<section id="setting-up-the-field-mesh">
<span id="running-cpp-parameters-box"></span><h2>Setting up the field mesh<a class="headerlink" href="#setting-up-the-field-mesh" title="Link to this heading"></a></h2>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amr.n_cell</span></code> (<cite>2 integers in 2D</cite>, <cite>3 integers in 3D</cite>)</dt><dd><p>The number of grid points along each direction (on the <strong>coarsest level</strong>)</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">amr.max_level</span></code> (<cite>integer</cite>, default: <code class="docutils literal notranslate"><span class="pre">0</span></code>)</dt><dd><p>When using mesh refinement, the number of refinement levels that will be used.</p>
<p>Use 0 in order to disable mesh refinement.
Note: currently, <code class="docutils literal notranslate"><span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">1</span></code> are supported.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amr.ref_ratio</span></code> (<cite>integer</cite> per refined level, default: <code class="docutils literal notranslate"><span class="pre">2</span></code>)</dt><dd><p>When using mesh refinement, this is the refinement ratio per level.
With this option, all directions are fined by the same ratio.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">amr.ref_ratio_vect</span></code> (<cite>3 integers for x,y,z per refined level</cite>)</dt><dd><p>When using mesh refinement, this can be used to set the refinement ratio per direction and level, relative to the previous level.</p>
<p>Example: for three levels, a value of <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">2</span> <span class="pre">4</span> <span class="pre">8</span> <span class="pre">8</span> <span class="pre">16</span></code> refines the first level by 2-fold in x and y and 4-fold in z compared to the coarsest level (level 0/mother grid); compared to the first level, the second level is refined 8-fold in x and y and 16-fold in z.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">geometry.dims</span></code> (<cite>string</cite>)</dt><dd><p>The dimensions of the simulation geometry.
Supported values are <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code>, <code class="docutils literal notranslate"><span class="pre">RZ</span></code>.
For <code class="docutils literal notranslate"><span class="pre">3</span></code>, a cartesian geometry of <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> is modeled.
For <code class="docutils literal notranslate"><span class="pre">2</span></code>, the axes are <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> and all physics in <code class="docutils literal notranslate"><span class="pre">y</span></code> is assumed to be translation symmetric.
For <code class="docutils literal notranslate"><span class="pre">1</span></code>, the only axis is <code class="docutils literal notranslate"><span class="pre">z</span></code> and the dimensions <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are translation symmetric.
For <code class="docutils literal notranslate"><span class="pre">RZ</span></code>, we apply an azimuthal mode decomposition, with <code class="docutils literal notranslate"><span class="pre">warpx.n_rz_azimuthal_modes</span></code> providing further control.</p>
<p>Note that this value has to match the <a class="reference internal" href="../install/cmake.html#building-cmake-options"><span class="std std-ref">WarpX_DIMS</span></a> compile-time option.
If you installed WarpX from a <a class="reference internal" href="../install/users.html#install-users"><span class="std std-ref">package manager</span></a>, then pick the right executable by name.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.n_rz_azimuthal_modes</span></code> (<cite>integer</cite>; 1 by default)</dt><dd><p>When using the RZ version, this is the number of azimuthal modes.
The default is <code class="docutils literal notranslate"><span class="pre">1</span></code>, which corresponds to a perfectly axisymmetric simulation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">geometry.prob_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">geometry.prob_hi</span></code> (<cite>2 floats in 2D</cite>, <cite>3 floats in 3D</cite>; in meters)</dt><dd><p>The extent of the full simulation box. This box is rectangular, and thus its
extent is given here by the coordinates of the lower corner (<code class="docutils literal notranslate"><span class="pre">geometry.prob_lo</span></code>) and
upper corner (<code class="docutils literal notranslate"><span class="pre">geometry.prob_hi</span></code>). The first axis of the coordinates is x
(or r with cylindrical) and the last is z.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_moving_window</span></code> (<cite>integer</cite>; 0 by default)</dt><dd><p>Whether to use a moving window for the simulation</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.moving_window_dir</span></code> (either <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">z</span></code>)</dt><dd><p>The direction of the moving window.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.moving_window_v</span></code> (<cite>float</cite>)</dt><dd><p>The speed of moving window, in units of the speed of light
(i.e. use <code class="docutils literal notranslate"><span class="pre">1.0</span></code> for a moving window that moves exactly at the speed of light)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.start_moving_window_step</span></code> (<cite>integer</cite>; 0 by default)</dt><dd><p>The timestep at which the moving window starts.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.end_moving_window_step</span></code> (<cite>integer</cite>; default is <code class="docutils literal notranslate"><span class="pre">-1</span></code> for false)</dt><dd><p>The timestep at which the moving window ends.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.fine_tag_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">warpx.fine_tag_hi</span></code> (<cite>2 floats in 2D</cite>, <cite>3 floats in 3D</cite>; in meters) optional</dt><dd><p><strong>When using static mesh refinement with 1 level</strong>, the extent of the refined patch.
This patch is rectangular, and thus its extent is given here by the coordinates
of the lower corner (<code class="docutils literal notranslate"><span class="pre">warpx.fine_tag_lo</span></code>) and upper corner (<code class="docutils literal notranslate"><span class="pre">warpx.fine_tag_hi</span></code>).</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.refine_plasma</span></code> (<cite>integer</cite>) optional (default <cite>0</cite>)</dt><dd><p>Increase the number of macro-particles that are injected “ahead” of a mesh
refinement patch in a moving window simulation.</p>
<p>Note: in development; only works with static mesh-refinement, specific
to moving window plasma injection, and requires a single refined level.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.n_current_deposition_buffer</span></code> (<cite>integer</cite>)</dt><dd><p>When using mesh refinement: the particles that are located inside
a refinement patch, but within <code class="docutils literal notranslate"><span class="pre">n_current_deposition_buffer</span></code> cells of
the edge of this patch, will deposit their charge and current to the
lower refinement level, instead of depositing to the refinement patch
itself. See the <a class="reference internal" href="../theory/amr.html#theory-amr"><span class="std std-ref">mesh-refinement section</span></a> for more details.
If this variable is not explicitly set in the input script,
<code class="docutils literal notranslate"><span class="pre">n_current_deposition_buffer</span></code> is automatically set so as to be large
enough to hold the particle shape, on the fine grid</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.n_field_gather_buffer</span></code> (<cite>integer</cite>, optional)</dt><dd><p>Default: <code class="docutils literal notranslate"><span class="pre">warpx.n_field_gather_buffer</span> <span class="pre">=</span> <span class="pre">n_current_deposition_buffer</span> <span class="pre">+</span> <span class="pre">1</span></code> (one cell larger than <code class="docutils literal notranslate"><span class="pre">n_current_deposition_buffer</span></code> on the fine grid).</p>
<p>When using mesh refinement, particles that are located inside a refinement patch, but within <code class="docutils literal notranslate"><span class="pre">n_field_gather_buffer</span></code> cells of the edge of the patch, gather the fields from the lower refinement level, instead of gathering the fields from the refinement patch itself.
This avoids some of the spurious effects that can occur inside the refinement patch, close to its edge.
See the section <a class="reference internal" href="../theory/amr.html#theory-amr"><span class="std std-ref">Mesh refinement</span></a> for more details.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_single_precision_comms</span></code> (<cite>integer</cite>; 0 by default)</dt><dd><p>Perform MPI communications for field guard regions in single precision.
Only meaningful for <code class="docutils literal notranslate"><span class="pre">WarpX_PRECISION=DOUBLE</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.deposit_on_main_grid</span></code> (<cite>list of strings</cite>)</dt><dd><p>When using mesh refinement: the particle species whose name are included
in the list will deposit their charge/current directly on the main grid
(i.e. the coarsest level), even if they are inside a refinement patch.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.gather_from_main_grid</span></code> (<cite>list of strings</cite>)</dt><dd><p>When using mesh refinement: the particle species whose name are included
in the list will gather their fields from the main grid
(i.e. the coarsest level), even if they are inside a refinement patch.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="domain-boundary-conditions">
<span id="running-cpp-parameters-bc"></span><h2>Domain Boundary Conditions<a class="headerlink" href="#domain-boundary-conditions" title="Link to this heading"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">boundary.field_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">boundary.field_hi</span></code> (<cite>2 strings</cite> for 2D, <cite>3 strings</cite> for 3D, <cite>pml</cite> by default)</dt><dd><p>Boundary conditions applied to fields at the lower and upper domain boundaries.
Options are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Periodic</span></code>: This option can be used to set periodic domain boundaries. Note that if the fields for lo in a certain dimension are set to periodic, then the corresponding upper boundary must also be set to periodic. If particle boundaries are not specified in the input file, then particles boundaries by default will be set to periodic. If particles boundaries are specified, then they must be set to periodic corresponding to the periodic field boundaries.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pml</span></code> (default): This option can be used to add Perfectly Matched Layers (PML) around the simulation domain. See the <a class="reference internal" href="../theory/PML.html#theory-bc"><span class="std std-ref">PML theory section</span></a> for more details.
Additional pml algorithms can be explored using the parameters <code class="docutils literal notranslate"><span class="pre">warpx.do_pml_in_domain</span></code>, <code class="docutils literal notranslate"><span class="pre">warpx.pml_has_particles</span></code>, and <code class="docutils literal notranslate"><span class="pre">warpx.do_pml_j_damping</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">absorbing_silver_mueller</span></code>: This option can be used to set the Silver-Mueller absorbing boundary conditions. These boundary conditions are simpler and less computationally expensive than the pml, but are also less effective at absorbing the field. They only work with the Yee Maxwell solver.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">damped</span></code>: This is the recommended option in the moving direction when using the spectral solver with moving window (currently only supported along z). This boundary condition applies a damping factor to the electric and magnetic fields in the outer half of the guard cells, using a sine squared profile. As the spectral solver is by nature periodic, the damping prevents fields from wrapping around to the other end of the domain when the periodicity is not desired. This boundary condition is only valid when using the spectral solver.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pec</span></code>: This option can be used to set a Perfect Electric Conductor at the simulation boundary. Please see the <a class="reference internal" href="../theory/PML.html#theory-bc-pec"><span class="std std-ref">PEC theory section</span></a> for more details. Note that PEC boundary is invalid at <cite>r=0</cite> for the RZ solver. Please use <code class="docutils literal notranslate"><span class="pre">none</span></code> option. This boundary condition does not work with the spectral solver.
If an electrostatic field solve is used the boundary potentials can also be set through <code class="docutils literal notranslate"><span class="pre">boundary.potential_lo_x/y/z</span></code> and <code class="docutils literal notranslate"><span class="pre">boundary.potential_hi_x/y/z</span></code> (default <cite>0</cite>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">none</span></code>: No boundary condition is applied to the fields with the electromagnetic solver. This option must be used for the RZ-solver at <cite>r=0</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">neumann</span></code>: For the electrostatic solver, a Neumann boundary condition (with gradient of the potential equal to 0) will be applied on the specified boundary.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">boundary.particle_lo</span></code> and <code class="docutils literal notranslate"><span class="pre">boundary.particle_hi</span></code> (<cite>2 strings</cite> for 2D, <cite>3 strings</cite> for 3D, <cite>absorbing</cite> by default)</dt><dd><p>Options are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Absorbing</span></code>: Particles leaving the boundary will be deleted.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Periodic</span></code>: Particles leaving the boundary will re-enter from the opposite boundary. The field boundary condition must be consistenly set to periodic and both lower and upper boundaries must be periodic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Reflecting</span></code>: Particles leaving the boundary are reflected from the boundary back into the domain.
When <code class="docutils literal notranslate"><span class="pre">boundary.reflect_all_velocities</span></code> is false, the sign of only the normal velocity is changed, otherwise the sign of all velocities are changed.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">boundary.reflect_all_velocities</span></code> (<cite>bool</cite>) optional (default <cite>false</cite>)</dt><dd><p>For a reflecting boundary condition, this flags whether the sign of only the normal velocity is changed or all velocities.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">boundary.verboncoeur_axis_correction</span></code> (<cite>bool</cite>) optional (default <cite>true</cite>)</dt><dd><p>Whether to apply the Verboncoeur correction on the charge and current density on axis when using RZ.
For nodal values (rho and Jz), the cell volume for values on axis is calculated as <span class="math notranslate nohighlight">\(\pi*\Delta r^2/4\)</span>.
In <a class="reference external" href="https://doi.org/10.1006/jcph.2001.6923">Verboncoeur JCP 174, 421-427 (2001)</a>, it is shown that using
<span class="math notranslate nohighlight">\(\pi*\Delta r^2/3\)</span> instead will give a uniform density if the particle density is uniform.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="additional-pml-parameters">
<h2>Additional PML parameters<a class="headerlink" href="#additional-pml-parameters" title="Link to this heading"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.pml_ncell</span></code> (<cite>int</cite>; default: 10)</dt><dd><p>The depth of the PML, in number of cells.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">do_similar_dm_pml</span></code> (<cite>int</cite>; default: 1)</dt><dd><p>Whether or not to use an amrex::DistributionMapping for the PML grids that is <cite>similar</cite> to the mother grids, meaning that the
mapping will be computed to minimize the communication costs between the PML and the mother grids.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.pml_delta</span></code> (<cite>int</cite>; default: 10)</dt><dd><p>The characteristic depth, in number of cells, over which
the absorption coefficients of the PML increases.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_pml_in_domain</span></code> (<cite>int</cite>; default: 0)</dt><dd><p>Whether to create the PML inside the simulation area or outside. If inside,
it allows the user to propagate particles in PML and to use extended PML</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.pml_has_particles</span></code> (<cite>int</cite>; default: 0)</dt><dd><p>Whether to propagate particles in PML or not. Can only be done if PML are in simulation domain,
i.e. if <cite>warpx.do_pml_in_domain = 1</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_pml_j_damping</span></code> (<cite>int</cite>; default: 0)</dt><dd><p>Whether to damp current in PML. Can only be used if particles are propagated in PML,
i.e. if <cite>warpx.pml_has_particles = 1</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.v_particle_pml</span></code> (<cite>float</cite>; default: 1)</dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">warpx.do_pml_j_damping</span> <span class="pre">=</span> <span class="pre">1</span></code>, the assumed velocity of the particles to be absorbed in the PML, in units of the speed of light <cite>c</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_pml_dive_cleaning</span></code> (<cite>bool</cite>; default: 1)</dt><dd><p>Whether to use divergence cleaning for E in the PML region.
The value must match <code class="docutils literal notranslate"><span class="pre">warpx.do_pml_divb_cleaning</span></code> (either both false or both true).
This option seems to be necessary in order to avoid strong Nyquist instabilities in 3D simulations with the PSATD solver, open boundary conditions and PML in all directions. 2D simulations and 3D simulations with open boundary conditions and PML only in one direction might run well even without divergence cleaning.
This option is implemented only for the PSATD solver.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_pml_divb_cleaning</span></code> (<cite>bool</cite>; default: 1)</dt><dd><p>Whether to use divergence cleaning for B in the PML region.
The value must match <code class="docutils literal notranslate"><span class="pre">warpx.do_pml_dive_cleaning</span></code> (either both false or both true).
This option seems to be necessary in order to avoid strong Nyquist instabilities in 3D simulations with the PSATD solver, open boundary conditions and PML in all directions. 2D simulations and 3D simulations with open boundary conditions and PML only in one direction might run well even without divergence cleaning.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="embedded-boundary-conditions">
<span id="running-cpp-parameters-eb"></span><h2>Embedded Boundary Conditions<a class="headerlink" href="#embedded-boundary-conditions" title="Link to this heading"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.eb_implicit_function</span></code> (<cite>string</cite>)</dt><dd><p>A function of <cite>x</cite>, <cite>y</cite>, <cite>z</cite> that defines the surface of the embedded
boundary. That surface lies where the function value is 0 ;
the physics simulation area is where the function value is negative ;
the interior of the embeddded boundary is where the function value is positive.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.eb_potential(x,y,z,t)</span></code> (<cite>string</cite>)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">warpx.do_electrostatic=labframe</span></code>. Gives the value of
the electric potential at the surface of the embedded boundary,
as a function of  <cite>x</cite>, <cite>y</cite>, <cite>z</cite> and time. This function is also evaluated
inside the embedded boundary. For this reason, it is important to define
this function in such a way that it is constant inside the embedded boundary.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="distribution-across-mpi-ranks-and-parallelization">
<span id="running-cpp-parameters-parallelization"></span><h2>Distribution across MPI ranks and parallelization<a class="headerlink" href="#distribution-across-mpi-ranks-and-parallelization" title="Link to this heading"></a></h2>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.numprocs</span></code> (<cite>2 ints</cite> for 2D, <cite>3 ints</cite> for 3D) optional (default <cite>none</cite>)</dt><dd><p>This optional parameter can be used to control the domain decomposition on the
coarsest level. The domain will be chopped into the exact number of pieces in each
dimension as specified by this parameter. If it’s not specified, the domain
decomposition will be determined by the parameters that will be discussed below.  If
specified, the product of the numbers must be equal to the number of MPI processes.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">amr.max_grid_size</span></code> (<cite>integer</cite>) optional (default <cite>128</cite>)</dt><dd><p>Maximum allowable size of each <strong>subdomain</strong>
(expressed in number of grid points, in each direction).
Each subdomain has its own ghost cells, and can be handled by a
different MPI rank ; several OpenMP threads can work simultaneously on the
same subdomain.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">max_grid_size</span></code> is such that the total number of subdomains is
<strong>larger</strong> that the number of MPI ranks used, than some MPI ranks
will handle several subdomains, thereby providing additional flexibility
for <strong>load balancing</strong>.</p>
<p>When using mesh refinement, this number applies to the subdomains
of the coarsest level, but also to any of the finer level.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.load_balance_intervals</span></code> (<cite>string</cite>) optional (default <cite>0</cite>)</dt><dd><p>Using the <a class="reference internal" href="#intervals-parser">Intervals parser</a> syntax, this string defines the timesteps at which
WarpX should try to redistribute the work across MPI ranks, in order to have
better load balancing.
Use 0 to disable load_balancing.</p>
<p>When performing load balancing, WarpX measures the wall time for
computational parts of the PIC cycle. It then uses this data to decide
how to redistribute the subdomains across MPI ranks. (Each subdomain
is unchanged, but its owner is changed in order to have better performance.)
This relies on each MPI rank handling several (in fact many) subdomains
(see <code class="docutils literal notranslate"><span class="pre">max_grid_size</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">algo.load_balance_efficiency_ratio_threshold</span></code> (<cite>float</cite>) optional (default <cite>1.1</cite>)</dt><dd><p>Controls whether to adopt a proposed distribution mapping computed during a load balance.
If the the ratio of the proposed to current distribution mapping <em>efficiency</em> (i.e.,
average cost per MPI process; efficiency is a number in the range [0, 1]) is greater
than the threshold value, the proposed distribution mapping is adopted.  The suggested
range of values is <code class="docutils literal notranslate"><span class="pre">algo.load_balance_efficiency_ratio_threshold</span> <span class="pre">&gt;=</span> <span class="pre">1</span></code>, which ensures
that the new distribution mapping is adopted only if doing so would improve the load
balance efficiency. The higher the threshold value, the more conservative is the criterion
for adoption of a proposed distribution; for example, with
<code class="docutils literal notranslate"><span class="pre">algo.load_balance_efficiency_ratio_threshold</span> <span class="pre">=</span> <span class="pre">1</span></code>, the proposed distribution is
adopted <em>any</em> time the proposed distribution improves load balancing; if instead
<code class="docutils literal notranslate"><span class="pre">algo.load_balance_efficiency_ratio_threshold</span> <span class="pre">=</span> <span class="pre">2</span></code>, the proposed distribution is
adopted only if doing so would yield a 100% to the load balance efficiency (with this
threshold value, if the  current efficiency is <code class="docutils literal notranslate"><span class="pre">0.45</span></code>, the new distribution would only be
adopted if the proposed efficiency were greater than <code class="docutils literal notranslate"><span class="pre">0.9</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">algo.load_balance_with_sfc</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>If this is <cite>1</cite>: use a Space-Filling Curve (SFC) algorithm in order to
perform load-balancing of the simulation.
If this is <cite>0</cite>: the Knapsack algorithm is used instead.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">algo.load_balance_knapsack_factor</span></code> (<cite>float</cite>) optional (default <cite>1.24</cite>)</dt><dd><p>Controls the maximum number of boxes that can be assigned to a rank during
load balance when using the ‘knapsack’ policy for update of the distribution
mapping; the maximum is
<cite>load_balance_knapsack_factor*(average number of boxes per rank)</cite>.
For example, if there are 4 boxes per rank and <cite>load_balance_knapsack_factor=2</cite>,
no more than 8 boxes can be assigned to any rank.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.load_balance_costs_update</span></code> (<cite>heuristic</cite> or <cite>timers</cite> or <cite>gpuclock</cite>) optional (default <cite>timers</cite>)</dt><dd><p>If this is <cite>heuristic</cite>: load balance costs are updated according to a measure of
particles and cells assigned to each box of the domain.  The cost <span class="math notranslate nohighlight">\(c\)</span> is
computed as</p>
<div class="math notranslate nohighlight">
\[c = n_{\text{particle}} \cdot w_{\text{particle}} + n_{\text{cell}} \cdot w_{\text{cell}},\]</div>
<p>where
<span class="math notranslate nohighlight">\(n_{\text{particle}}\)</span> is the number of particles on the box,
<span class="math notranslate nohighlight">\(w_{\text{particle}}\)</span> is the particle cost weight factor (controlled by <code class="docutils literal notranslate"><span class="pre">algo.costs_heuristic_particles_wt</span></code>),
<span class="math notranslate nohighlight">\(n_{\text{cell}}\)</span> is the number of cells on the box, and
<span class="math notranslate nohighlight">\(w_{\text{cell}}\)</span> is the cell cost weight factor (controlled by <code class="docutils literal notranslate"><span class="pre">algo.costs_heuristic_cells_wt</span></code>).</p>
<p>If this is <cite>timers</cite>: costs are updated according to in-code timers.</p>
<p>If this is <cite>gpuclock</cite>: [<strong>requires to compile with option</strong> <code class="docutils literal notranslate"><span class="pre">-DWarpX_GPUCLOCK=ON</span></code>]
costs are measured as (max-over-threads) time spent in current deposition
routine (only applies when running on GPUs).</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.costs_heuristic_particles_wt</span></code> (<cite>float</cite>) optional</dt><dd><p>Particle weight factor used in <cite>Heuristic</cite> strategy for costs update; if running on GPU,
the particle weight is set to a value determined from single-GPU tests on Summit,
depending on the choice of solver (FDTD or PSATD) and order of the particle shape.
If running on CPU, the default value is <cite>0.9</cite>. If running on GPU, the default value is</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head" colspan="3"><p>Particle shape factor</p></th>
</tr>
<tr class="row-even"><th class="head"></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>FDTD/CKC</p></td>
<td><p>0.599</p></td>
<td><p>0.732</p></td>
<td><p>0.855</p></td>
</tr>
<tr class="row-even"><td><p>PSATD</p></td>
<td><p>0.425</p></td>
<td><p>0.595</p></td>
<td><p>0.75</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.costs_heuristic_cells_wt</span></code> (<cite>float</cite>) optional</dt><dd><p>Cell weight factor used in <cite>Heuristic</cite> strategy for costs update; if running on GPU,
the cell weight is set to a value determined from single-GPU tests on Summit,
depending on the choice of solver (FDTD or PSATD) and order of the particle shape.
If running on CPU, the default value is <cite>0.1</cite>. If running on GPU, the default value is</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head" colspan="3"><p>Particle shape factor</p></th>
</tr>
<tr class="row-even"><th class="head"></th>
<th class="head"><p>1</p></th>
<th class="head"><p>2</p></th>
<th class="head"><p>3</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>FDTD/CKC</p></td>
<td><p>0.401</p></td>
<td><p>0.268</p></td>
<td><p>0.145</p></td>
</tr>
<tr class="row-even"><td><p>PSATD</p></td>
<td><p>0.575</p></td>
<td><p>0.405</p></td>
<td><p>0.25</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_dynamic_scheduling</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>1</cite>)</dt><dd><p>Whether to activate OpenMP dynamic scheduling.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="math-parser-and-user-defined-constants">
<span id="running-cpp-parameters-parser"></span><h2>Math parser and user-defined constants<a class="headerlink" href="#math-parser-and-user-defined-constants" title="Link to this heading"></a></h2>
<p>WarpX uses AMReX’s math parser that reads expressions in the input file.
It can be used in all input parameters that consist of one or more integers or floats.
Integer input expecting boolean, 0 or 1, are not parsed.
Note that when multiple values are expected, the expressions are space delimited.
For integer input values, the expressions are evaluated as real numbers and the final result rounded to the nearest integer.
See <a class="reference external" href="https://amrex-codes.github.io/amrex/docs_html/Basics.html#parser">this section</a> of the AMReX documentation for a complete list of functions supported by the math parser.</p>
<section id="warpx-constants">
<h3>WarpX constants<a class="headerlink" href="#warpx-constants" title="Link to this heading"></a></h3>
<p>WarpX provides a few pre-defined constants, that can be used for any parameter that consists of one or more floats.</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>q_e</p></td>
<td><p>elementary charge</p></td>
</tr>
<tr class="row-even"><td><p>m_e</p></td>
<td><p>electron mass</p></td>
</tr>
<tr class="row-odd"><td><p>m_p</p></td>
<td><p>proton mass</p></td>
</tr>
<tr class="row-even"><td><p>m_u</p></td>
<td><p>unified atomic mass unit (Dalton)</p></td>
</tr>
<tr class="row-odd"><td><p>epsilon0</p></td>
<td><p>vacuum permittivity</p></td>
</tr>
<tr class="row-even"><td><p>mu0</p></td>
<td><p>vacuum permeability</p></td>
</tr>
<tr class="row-odd"><td><p>clight</p></td>
<td><p>speed of light</p></td>
</tr>
<tr class="row-even"><td><p>kb</p></td>
<td><p>Boltzmann’s constant (J/K)</p></td>
</tr>
<tr class="row-odd"><td><p>pi</p></td>
<td><p>math constant pi</p></td>
</tr>
<tr class="row-even"><td><p>kb</p></td>
<td><p>Boltzmann constant (J/K)</p></td>
</tr>
</tbody>
</table>
<p>See <code class="docutils literal notranslate"><span class="pre">Source/Utils/WarpXConst.H</span></code> for the values.</p>
</section>
<section id="user-defined-constants">
<h3>User-defined constants<a class="headerlink" href="#user-defined-constants" title="Link to this heading"></a></h3>
<p>Users can define their own constants in the input file.
These constants can be used for any parameter that consists of one or more integers or floats.
User-defined constant names can contain only letters, numbers and the character <code class="docutils literal notranslate"><span class="pre">_</span></code>.
The name of each constant has to begin with a letter. The following names are used
by WarpX, and cannot be used as user-defined constants: <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code>, <code class="docutils literal notranslate"><span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">Y</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code>.
The values of the constants can include the predefined WarpX constants listed above as well as other user-defined constants.
For example:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">my_constants.a0</span> <span class="pre">=</span> <span class="pre">3.0</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">my_constants.z_plateau</span> <span class="pre">=</span> <span class="pre">150.e-6</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">my_constants.n0</span> <span class="pre">=</span> <span class="pre">1.e22</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">my_constants.wp</span> <span class="pre">=</span> <span class="pre">sqrt(n0*q_e**2/(epsilon0*m_e))</span></code></p></li>
</ul>
</section>
<section id="coordinates">
<h3>Coordinates<a class="headerlink" href="#coordinates" title="Link to this heading"></a></h3>
<p>Besides, for profiles that depend on spatial coordinates (the plasma momentum distribution or the laser field, see below <cite>Particle initialization</cite> and <cite>Laser initialization</cite>), the parser will interpret some variables as spatial coordinates. These are specified in the input parameter, i.e., <code class="docutils literal notranslate"><span class="pre">density_function(x,y,z)</span></code> and <code class="docutils literal notranslate"><span class="pre">field_function(X,Y,t)</span></code>.</p>
<p>The parser reads python-style expressions between double quotes, for instance
<code class="docutils literal notranslate"><span class="pre">&quot;a0*x**2</span> <span class="pre">*</span> <span class="pre">(1-y*1.e2)</span> <span class="pre">*</span> <span class="pre">(x&gt;0)&quot;</span></code> is a valid expression where <code class="docutils literal notranslate"><span class="pre">a0</span></code> is a
user-defined constant (see above) and <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> are spatial coordinates. The names are case sensitive. The factor
<code class="docutils literal notranslate"><span class="pre">(x&gt;0)</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code> where <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span></code> where <code class="docutils literal notranslate"><span class="pre">x&lt;=0</span></code>. It allows the user to
define functions by intervals.
Alternatively the expression above can be written as <code class="docutils literal notranslate"><span class="pre">if(x&gt;0,</span> <span class="pre">a0*x**2</span> <span class="pre">*</span> <span class="pre">(1-y*1.e2),</span> <span class="pre">0)</span></code>.</p>
</section>
</section>
<section id="particle-initialization">
<span id="running-cpp-parameters-particle"></span><h2>Particle initialization<a class="headerlink" href="#particle-initialization" title="Link to this heading"></a></h2>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.species_names</span></code> (<cite>strings</cite>, separated by spaces)</dt><dd><p>The name of each species. This is then used in the rest of the input deck ;
in this documentation we use <cite>&lt;species_name&gt;</cite> as a placeholder.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.photon_species</span></code> (<cite>strings</cite>, separated by spaces)</dt><dd><p>List of species that are photon species, if any.
<strong>This is required when compiling with QED=TRUE.</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.use_fdtd_nci_corr</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Whether to activate the FDTD Numerical Cherenkov Instability corrector.
Not currently available in the RZ configuration.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.rigid_injected_species</span></code> (<cite>strings</cite>, separated by spaces)</dt><dd><p>List of species injected using the rigid injection method. The rigid injection
method is useful when injecting a relativistic particle beam, in boosted-frame
simulation ; see the <a class="reference internal" href="../theory/input_output.html#theory-io"><span class="std std-ref">input-output section</span></a> for more details.
For species injected using this method, particles are translated along the <cite>+z</cite>
axis with constant velocity as long as their <code class="docutils literal notranslate"><span class="pre">z</span></code> coordinate verifies
<code class="docutils literal notranslate"><span class="pre">z&lt;zinject_plane</span></code>. When <code class="docutils literal notranslate"><span class="pre">z&gt;zinject_plane</span></code>,
particles are pushed in a standard way, using the specified pusher.
(see the parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.zinject_plane</span></code> below)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">particles.do_tiling</span></code> (<cite>bool</cite>) optional (default <cite>false</cite> if WarpX is compiled for GPUs, <cite>true</cite> otherwise)</dt><dd><p>Controls whether tiling (‘cache blocking’) transformation is used for particles.
Tiling should be on when using OpenMP and off when using GPUs.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.species_type</span></code> (<cite>string</cite>) optional (default <cite>unspecified</cite>)</dt><dd><p>Type of physical species.
Currently, the accepted species are
<code class="docutils literal notranslate"><span class="pre">&quot;electron&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;positron&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;muon&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;antimuon&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;photon&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;neutron&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;proton&quot;</span></code> , <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;hydrogen1&quot;</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">&quot;protium&quot;</span></code>), <code class="docutils literal notranslate"><span class="pre">&quot;hydrogen2&quot;</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">&quot;deuterium&quot;</span></code>), <code class="docutils literal notranslate"><span class="pre">&quot;hydrogen3&quot;</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">&quot;tritium&quot;</span></code>),
<code class="docutils literal notranslate"><span class="pre">&quot;helium&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;helium3&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;helium4&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;lithium&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;lithium6&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;lithium7&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;beryllium&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;beryllium9&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;boron&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;boron10&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;boron11&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;carbon&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;carbon12&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;carbon13&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;carbon14&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;nitrogen&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;nitrogen14&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;nitrogen15&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;oxygen&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;oxygen16&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;oxygen17&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;oxygen18&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;fluorine&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;fluorine19&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;neon&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;neon20&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;neon21&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;neon22&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;aluminium&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;argon&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;copper&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;xenon&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;gold&quot;</span></code>.
The difference between <code class="docutils literal notranslate"><span class="pre">&quot;proton&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;hydrogen1&quot;</span></code> is that the mass of the latter includes also the mass
of the bound electron (same for <code class="docutils literal notranslate"><span class="pre">&quot;alpha&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;helium4&quot;</span></code>). When only the name of an element is specified, the mass
is a weighted average of the masses of the stable isotopes. For all the elements with <code class="docutils literal notranslate"><span class="pre">Z</span> <span class="pre">&lt;</span> <span class="pre">11</span></code> we provide
also the stable isotopes as an option for <code class="docutils literal notranslate"><span class="pre">species_type</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;helium3&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;helium4&quot;</span></code>).
Either <code class="docutils literal notranslate"><span class="pre">species_type</span></code> or both <code class="docutils literal notranslate"><span class="pre">mass</span></code> and <code class="docutils literal notranslate"><span class="pre">charge</span></code> have to be specified.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.charge</span></code> (<cite>float</cite>) optional (default <cite>NaN</cite>)</dt><dd><p>The charge of one <cite>physical</cite> particle of this species.
If <code class="docutils literal notranslate"><span class="pre">species_type</span></code> is specified, the charge will be set to the physical value and <code class="docutils literal notranslate"><span class="pre">charge</span></code> is optional.
When <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_field_ionization</span> <span class="pre">=</span> <span class="pre">1</span></code>, the physical particle charge is equal to <code class="docutils literal notranslate"><span class="pre">ionization_initial_level</span> <span class="pre">*</span> <span class="pre">charge</span></code>, so latter parameter should be equal to q_e (which is defined in WarpX as the elementary charge in coulombs).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.mass</span></code> (<cite>float</cite>) optional (default <cite>NaN</cite>)</dt><dd><p>The mass of one <cite>physical</cite> particle of this species.
If <code class="docutils literal notranslate"><span class="pre">species_type</span></code> is specified, the mass will be set to the physical value and <code class="docutils literal notranslate"><span class="pre">mass</span></code> is optional.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.xmin,ymin,zmin</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.xmax,ymax,zmax</span></code> (<cite>float</cite>) optional (default unlimited)</dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.xmin</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.xmax</span></code> are set, they delimit the region within which particles are injected.
If periodic boundary conditions are used in direction <code class="docutils literal notranslate"><span class="pre">i</span></code>, then the default (i.e. if the range is not specified) range will be the simulation box, <code class="docutils literal notranslate"><span class="pre">[geometry.prob_hi[i],</span> <span class="pre">geometry.prob_lo[i]]</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.injection_style</span></code> (<cite>string</cite>; default: <code class="docutils literal notranslate"><span class="pre">none</span></code>)</dt><dd><p>Determines how the (macro-)particles will be injected in the simulation.
The number of particles per cell is always given with respect to the coarsest level (level 0/mother grid), even if particles are immediately assigned to a refined patch.</p>
<p>The options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">NUniformPerCell</span></code>: injection with a fixed number of evenly-spaced particles per cell.
This requires the additional parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.num_particles_per_cell_each_dim</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NRandomPerCell</span></code>: injection with a fixed number of randomly-distributed particles per cell.
This requires the additional parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.num_particles_per_cell</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SingleParticle</span></code>: Inject a single macroparticle.
This requires the additional parameters:
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.single_particle_pos</span></code> (<cite>3 doubles</cite>, particle 3D position [meter])
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.single_particle_u</span></code> (<cite>3 doubles</cite>, particle 3D normalized momentum, i.e. <span class="math notranslate nohighlight">\(\gamma \beta\)</span>)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.single_particle_weight</span></code> ( <cite>double</cite>, macroparticle weight, i.e. number of physical particles it represents)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MultipleParticles</span></code>: Inject multiple macroparticles.
This requires the additional parameters:
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_pos_x</span></code> (list of <cite>doubles</cite>, X positions of the particles [meter])
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_pos_y</span></code> (list of <cite>doubles</cite>, Y positions of the particles [meter])
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_pos_z</span></code> (list of <cite>doubles</cite>, Z positions of the particles [meter])
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_ux</span></code> (list of <cite>doubles</cite>, X normalized momenta of the particles, i.e. <span class="math notranslate nohighlight">\(\gamma \beta_x\)</span>)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_uy</span></code> (list of <cite>doubles</cite>, Y normalized momenta of the particles, i.e. <span class="math notranslate nohighlight">\(\gamma \beta_y\)</span>)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_uz</span></code> (list of <cite>doubles</cite>, Z normalized momenta of the particles, i.e. <span class="math notranslate nohighlight">\(\gamma \beta_z\)</span>)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.multiple_particles_weight</span></code> (list of <cite>doubles</cite>, macroparticle weights, i.e. number of physical particles each represents)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gaussian_beam</span></code>: Inject particle beam with gaussian distribution in
space in all directions. This requires additional parameters:
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.q_tot</span></code> (beam charge),
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.npart</span></code> (number of particles in the beam),
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.x/y/z_m</span></code> (average position in <cite>x/y/z</cite>),
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.x/y/z_rms</span></code> (standard deviation in <cite>x/y/z</cite>),
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.x/y/z_cut</span></code> (optional, particles with <code class="docutils literal notranslate"><span class="pre">abs(x-x_m)</span> <span class="pre">&gt;</span> <span class="pre">x_cut*x_rms</span></code> are not injected, same for y and z. <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.q_tot</span></code> is the charge of the un-cut beam, so that cutting the distribution is likely to result in a lower total charge),
and optional arguments <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_symmetrize</span></code> (whether to
symmetrize the beam) and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.symmetrization_order</span></code> (order of symmetrization, default is 4, can be 4 or 8).
If <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_symmetrize</span></code> is 0, no symmetrization occurs.  If <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_symmetrize</span></code> is 1,
then the beam is symmetrized according to the value of <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.symmetrization_order</span></code>.
If set to 4, symmetrization is in the x and y direction, (x,y) (-x,y) (x,-y) (-x,-y).
If set to 8, symmetrization is also done with x and y exchanged, (y,x), (-y,x), (y,-x), (-y,-x)).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">external_file</span></code>: Inject macroparticles with properties (mass, charge, position, and momentum - <span class="math notranslate nohighlight">\(\gamma \beta m c\)</span>) read from an external openPMD file.
With it users can specify the additional arguments:
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.injection_file</span></code> (<cite>string</cite>) openPMD file name and
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.charge</span></code> (<cite>double</cite>) optional (default is read from openPMD file) when set this will be the charge of the physical particle represented by the injected macroparticles.
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.mass</span></code> (<cite>double</cite>) optional (default is read from openPMD file) when set this will be the charge of the physical particle represented by the injected macroparticles.
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.z_shift</span></code> (<cite>double</cite>) optional (default is no shift) when set this value will be added to the longitudinal, <code class="docutils literal notranslate"><span class="pre">z</span></code>, position of the particles.
Warning: <code class="docutils literal notranslate"><span class="pre">q_tot!=0</span></code> is not supported with the <code class="docutils literal notranslate"><span class="pre">external_file</span></code> injection style. If a value is provided, it is ignored and no re-scaling is done.
The external file must include the species <code class="docutils literal notranslate"><span class="pre">openPMD::Record</span></code> labeled <code class="docutils literal notranslate"><span class="pre">position</span></code> and <code class="docutils literal notranslate"><span class="pre">momentum</span></code> (<cite>double</cite> arrays), with dimensionality and units set via <code class="docutils literal notranslate"><span class="pre">openPMD::setUnitDimension</span></code> and <code class="docutils literal notranslate"><span class="pre">setUnitSI</span></code>.
If the external file also contains <code class="docutils literal notranslate"><span class="pre">openPMD::Records</span></code> for <code class="docutils literal notranslate"><span class="pre">mass</span></code> and <code class="docutils literal notranslate"><span class="pre">charge</span></code> (constant <cite>double</cite> scalars) then the species will use these, unless overwritten in the input file (see <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.mass</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.charge</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.species_type</span></code>).
The <code class="docutils literal notranslate"><span class="pre">external_file</span></code> option is currently implemented for 2D, 3D and RZ geometries, with record components in the cartesian coordinates <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> for 3D and RZ, and <code class="docutils literal notranslate"><span class="pre">(x,z)</span></code> for 2D.
For more information on the <a class="reference external" href="https://github.com/openPMD">openPMD format</a> and how to build WarpX with it, please visit <a class="reference internal" href="../install/cmake.html#install-developers"><span class="std std-ref">the install section</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">NFluxPerCell</span></code>: Continuously inject a flux of macroparticles from a planar surface.
The density specified by the density profile is interpreted to have the units of #/m^2/s.
This requires the additional parameters:
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.surface_flux_pos</span></code> (<cite>double</cite>, location of the injection plane [meter])
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.flux_normal_axis</span></code> (<cite>x</cite>, <cite>y</cite>, or <cite>z</cite> for 3D, <cite>x</cite> or <cite>z</cite> for 2D, or <cite>r</cite>, <cite>t</cite>, or <cite>z</cite> for RZ. When <cite>flux_normal_axis</cite> is <cite>r</cite> or <cite>t</cite>, the <cite>x</cite> and <cite>y</cite> components of the user-specified momentum distribution are interpreted as the <cite>r</cite> and <cite>t</cite> components respectively)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.flux_direction</span></code> (<cite>-1</cite> or <cite>+1</cite>, direction of flux relative to the plane)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.num_particles_per_cell</span></code> (<cite>double</cite>)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.flux_tmin</span></code> (<cite>double</cite>, Optional time at which the flux will be turned on. Ignored when negative.)
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.flux_tmax</span></code> (<cite>double</cite>, Optional time at which the flux will be turned off. Ignored when negative.)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">none</span></code>: Do not inject macro-particles (for example, in a simulation that starts with neutral, ionizable atoms, one may want to create the electrons species – where ionized electrons can be stored later on – without injecting electron macro-particles).</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.num_particles_per_cell_each_dim</span></code> (<cite>3 integers in 3D and RZ, 2 integers in 2D</cite>)</dt><dd><p>With the NUniformPerCell injection style, this specifies the number of particles along each axis
within a cell. Note that for RZ, the three axis are radius, theta, and z and that the recommended
number of particles per theta is at least two times the number of azimuthal modes requested.
(It is recommended to do a convergence scan of the number of particles per theta)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.random_theta</span></code> (<cite>bool</cite>) optional (default <cite>1</cite>)</dt><dd><p>When using RZ geometry, whether to randomize the azimuthal position of particles.
This is used when <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.injection_style</span> <span class="pre">=</span> <span class="pre">NUniformPerCell</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_splitting</span></code> (<cite>bool</cite>) optional (default <cite>0</cite>)</dt><dd><p>Split particles of the species when crossing the boundary from a lower
resolution domain to a higher resolution domain.</p>
<p>Currently implemented on CPU only.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_continuous_injection</span></code> (<cite>0</cite> or <cite>1</cite>)</dt><dd><p>Whether to inject particles during the simulation, and not only at
initialization. This can be required with a moving window and/or when
running in a boosted frame.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.initialize_self_fields</span></code> (<cite>0</cite> or <cite>1</cite>)</dt><dd><p>Whether to calculate the space-charge fields associated with this species
at the beginning of the simulation.
The fields are calculated for the mean gamma of the species.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.self_fields_required_precision</span></code> (<cite>float</cite>, default: 1.e-11)</dt><dd><p>The relative precision with which the initial space-charge fields should
be calculated. More specifically, the initial space-charge fields are
computed with an iterative Multi-Level Multi-Grid (MLMG) solver.
For highly-relativistic beams, this solver can fail to reach the default
precision within a reasonable time ; in that case, users can set a
relaxed precision requirement through <code class="docutils literal notranslate"><span class="pre">self_fields_required_precision</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.self_fields_absolute_tolerance</span></code> (<cite>float</cite>, default: 0.0)</dt><dd><p>The absolute tolerance with which the space-charge fields should be
calculated in units of <span class="math notranslate nohighlight">\(\mathrm{V/m}^2\)</span>. More specifically, the acceptable
residual with which the solution can be considered converged. In general
this should be left as the default, but in cases where the simulation state
changes very little between steps it can occur that the initial guess for
the MLMG solver is so close to the converged value that it fails to improve
that solution sufficiently to reach the <code class="docutils literal notranslate"><span class="pre">self_fields_required_precision</span></code>
value.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.self_fields_max_iters</span></code> (<cite>integer</cite>, default: 200)</dt><dd><p>Maximum number of iterations used for MLMG solver for initial space-charge
fields calculation. In case if MLMG converges but fails to reach the desired
<code class="docutils literal notranslate"><span class="pre">self_fields_required_precision</span></code>, this parameter may be increased.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.profile</span></code> (<cite>string</cite>)</dt><dd><p>Density profile for this species. The options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code>: Constant density profile within the box, or between <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.xmin</span></code>
and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.xmax</span></code> (and same in all directions). This requires additional
parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.density</span></code>. i.e., the plasma density in <span class="math notranslate nohighlight">\(m^{-3}\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">predefined</span></code>: Predefined density profile.
This requires additional parameters <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.predefined_profile_name</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.predefined_profile_params</span></code>.
Currently, only a parabolic channel density profile is implemented.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parse_density_function</span></code>: the density is given by a function in the input file.
It requires additional argument <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.density_function(x,y,z)</span></code>, which is a
mathematical expression for the density of the species, e.g.
<code class="docutils literal notranslate"><span class="pre">electrons.density_function(x,y,z)</span> <span class="pre">=</span> <span class="pre">&quot;n0+n0*x**2*1.e12&quot;</span></code> where <code class="docutils literal notranslate"><span class="pre">n0</span></code> is a
user-defined constant, see above. WARNING: where <code class="docutils literal notranslate"><span class="pre">density_function(x,y,z)</span></code> is close to zero, particles will still be injected between <code class="docutils literal notranslate"><span class="pre">xmin</span></code> and <code class="docutils literal notranslate"><span class="pre">xmax</span></code> etc., with a null weight. This is undesirable because it results in useless computing. To avoid this, see option <code class="docutils literal notranslate"><span class="pre">density_min</span></code> below.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.density_min</span></code> (<cite>float</cite>) optional (default <cite>0.</cite>)</dt><dd><p>Minimum plasma density. No particle is injected where the density is below this value.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.density_max</span></code> (<cite>float</cite>) optional (default <cite>infinity</cite>)</dt><dd><p>Maximum plasma density. The density at each point is the minimum between the value given in the profile, and <cite>density_max</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.radially_weighted</span></code> (<cite>bool</cite>) optional (default <cite>true</cite>)</dt><dd><p>Whether particle’s weight is varied with their radius. This only applies to cylindrical geometry.
The only valid value is true.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.momentum_distribution_type</span></code> (<cite>string</cite>)</dt><dd><p>Distribution of the normalized momentum (<cite>u=p/mc</cite>) for this species. The options are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">at_rest</span></code>: Particles are initialized with zero momentum.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code>: constant momentum profile. This can be controlled with the additional parameters
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.ux</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uy</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uz</span></code>, the normalized
momenta in the x, y and z direction respectively, which are all <code class="docutils literal notranslate"><span class="pre">0.</span></code> by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gaussian</span></code>: gaussian momentum distribution in all 3 directions. This can be controlled with the
additional arguments for the average momenta along each direction
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.ux_m</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uy_m</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uz_m</span></code> as
well as standard deviations along each direction <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.ux_th</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uy_th</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uz_th</span></code>.
These 6 parameters are all <code class="docutils literal notranslate"><span class="pre">0.</span></code> by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gaussianflux</span></code>: Gaussian momentum flux distribution, which is Gaussian in the plane and v*Gaussian normal to the plane.
It can only be used when <code class="docutils literal notranslate"><span class="pre">injection_style</span> <span class="pre">=</span> <span class="pre">NFluxPerCell</span></code>.
This can be controlled with the additional arguments to specify the plane’s orientation, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.flux_normal_axis</span></code> and
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.flux_direction</span></code>, for the average momenta along each direction
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.ux_m</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uy_m</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uz_m</span></code>, as
well as standard deviations along each direction <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.ux_th</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uy_th</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.uz_th</span></code>.
<code class="docutils literal notranslate"><span class="pre">ux_m</span></code>, <code class="docutils literal notranslate"><span class="pre">uy_m</span></code>, <code class="docutils literal notranslate"><span class="pre">uz_m</span></code>, <code class="docutils literal notranslate"><span class="pre">ux_th</span></code>, <code class="docutils literal notranslate"><span class="pre">uy_th</span></code> and <code class="docutils literal notranslate"><span class="pre">uz_th</span></code> are all <code class="docutils literal notranslate"><span class="pre">0.</span></code> by default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxwell_boltzmann</span></code>: Maxwell-Boltzmann distribution that takes a dimensionless
temperature parameter <span class="math notranslate nohighlight">\(\theta\)</span> as an input, where <span class="math notranslate nohighlight">\(\theta = \frac{k_\mathrm{B} \cdot T}{m \cdot c^2}\)</span>,
<span class="math notranslate nohighlight">\(T\)</span> is the temperature in Kelvin, <span class="math notranslate nohighlight">\(k_\mathrm{B}\)</span> is the Boltzmann constant, <span class="math notranslate nohighlight">\(c\)</span> is the speed of light, and <span class="math notranslate nohighlight">\(m\)</span> is the mass of the species.
Theta is specified by a combination of <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta_distribution_type</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta_function(x,y,z)</span></code> (see below).
For values of <span class="math notranslate nohighlight">\(\theta &gt; 0.01\)</span>, errors due to ignored relativistic terms exceed 1%.
Temperatures less than zero are not allowed.
The plasma can be initialized to move at a bulk velocity <span class="math notranslate nohighlight">\(\beta = v/c\)</span>.
The speed is specified by the parameters <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta_distribution_type</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta_function(x,y,z)</span></code> (see below).
<span class="math notranslate nohighlight">\(\beta\)</span> can be positive or negative and is limited to the range <span class="math notranslate nohighlight">\(-1 &lt; \beta &lt; 1\)</span>.
The direction of the velocity field is given by <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.bulk_vel_dir</span> <span class="pre">=</span> <span class="pre">(+/-)</span> <span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z'</span></code>, and must be the same across the domain.
Please leave no whitespace
between the sign and the character on input. A direction without a sign will be treated as
positive. The MB distribution is initialized in the drifting frame by sampling three Gaussian
distributions in each dimension using, the Box Mueller method, and then the distribution is
transformed to the simulation frame using the flipping method. The flipping method can be
found in Zenitani 2015 section III. B. (Phys. Plasmas 22, 042116).
By default, <code class="docutils literal notranslate"><span class="pre">beta</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">0.</span></code> and <code class="docutils literal notranslate"><span class="pre">bulk_vel_dir</span></code> is <code class="docutils literal notranslate"><span class="pre">+x</span></code>.</p>
<p>Note that though the particles may move at relativistic speeds in the simulation frame,
they are not relativistic in the drift frame. This is as opposed to the Maxwell Juttner
setting, which initializes particles with relativistic momentums in their drifting frame.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">maxwell_juttner</span></code>: Maxwell-Juttner distribution for high temperature plasma that takes a dimensionless temperature parameter <span class="math notranslate nohighlight">\(\theta\)</span> as an input, where <span class="math notranslate nohighlight">\(\theta = \frac{k_\mathrm{B} \cdot T}{m \cdot c^2}\)</span>,
<span class="math notranslate nohighlight">\(T\)</span> is the temperature in Kelvin, <span class="math notranslate nohighlight">\(k_\mathrm{B}\)</span> is the Boltzmann constant, and <span class="math notranslate nohighlight">\(m\)</span> is the mass of the species.
Theta is specified by a combination of <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta_distribution_type</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta_function(x,y,z)</span></code> (see below).
The Sobol method used to generate the distribution will not terminate for <span class="math notranslate nohighlight">\(\theta \lesssim 0.1\)</span>, and the code will abort if it encounters a temperature below that threshold.
The Maxwell-Boltzmann distribution is recommended for temperatures in the range <span class="math notranslate nohighlight">\(0.01 &lt; \theta &lt; 0.1\)</span>.
Errors due to relativistic effects can be expected to approximately between 1% and 10%.
The plasma can be initialized to move at a bulk velocity <span class="math notranslate nohighlight">\(\beta = v/c\)</span>.
The speed is specified by the parameters <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta_distribution_type</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta_function(x,y,z)</span></code> (see below).
<span class="math notranslate nohighlight">\(\beta\)</span> can be positive or negative and is limited to the range <span class="math notranslate nohighlight">\(-1 &lt; \beta &lt; 1\)</span>.
The direction of the velocity field is given by <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.bulk_vel_dir</span> <span class="pre">=</span> <span class="pre">(+/-)</span> <span class="pre">'x',</span> <span class="pre">'y',</span> <span class="pre">'z'</span></code>, and must be the same across the domain.
Please leave no whitespace
between the sign and the character on input. A direction without a sign will be treated as
positive. The MJ distribution will be initialized in the moving frame using the Sobol method,
and then the distribution will be transformed to the simulation frame using the flipping method.
Both the Sobol and the flipping method can be found in Zenitani 2015 (Phys. Plasmas 22, 042116).
By default, <code class="docutils literal notranslate"><span class="pre">beta</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">0.</span></code> and <code class="docutils literal notranslate"><span class="pre">bulk_vel_dir</span></code> is <code class="docutils literal notranslate"><span class="pre">+x</span></code>.</p>
<p>Please take notice that particles initialized with this setting can be relativistic in two ways.
In the simulation frame, they can drift with a relativistic speed beta. Then, in the drifting
frame they are still moving with relativistic speeds due to high temperature. This is as opposed
to the Maxwell Boltzmann setting, which initializes non-relativistic plasma in their relativistic
drifting frame.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">radial_expansion</span></code>: momentum depends on the radial coordinate linearly. This
can be controlled with additional parameter <code class="docutils literal notranslate"><span class="pre">u_over_r</span></code> which is the slope (<code class="docutils literal notranslate"><span class="pre">0.</span></code> by default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parse_momentum_function</span></code>: the momentum is given by a function in the input
file. It requires additional arguments <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.momentum_function_ux(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.momentum_function_uy(x,y,z)</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.momentum_function_uz(x,y,z)</span></code>,
which gives the distribution of each component of the momentum as a function of space.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta_distribution_type</span></code> (<cite>string</cite>) optional (default <code class="docutils literal notranslate"><span class="pre">constant</span></code>)</dt><dd><p>Only read if <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.momentum_distribution_type</span></code> is <code class="docutils literal notranslate"><span class="pre">maxwell_boltzmann</span></code> or <code class="docutils literal notranslate"><span class="pre">maxwell_juttner</span></code>.
See documentation for these distributions (above) for constraints on values of theta. Temperatures less than zero are not allowed.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">constant</span></code>, use a constant temperature, given by the required float parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">parser</span></code>, use a spatially-dependent analytic parser function, given by the required parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.theta_function(x,y,z)</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta_distribution_type</span></code> (<cite>string</cite>) optional (default <code class="docutils literal notranslate"><span class="pre">constant</span></code>)</dt><dd><p>Only read if <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.momentum_distribution_type</span></code> is <code class="docutils literal notranslate"><span class="pre">maxwell_boltzmann</span></code> or <code class="docutils literal notranslate"><span class="pre">maxwell_juttner</span></code>.
See documentation for these distributions (above) for constraints on values of beta.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">constant</span></code>, use a constant speed, given by the required float parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">parser</span></code>, use a spatially-dependent analytic parser function, given by the required parameter <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.beta_function(x,y,z)</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.zinject_plane</span></code> (<cite>float</cite>)</dt><dd><p>Only read if  <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;</span></code> is in <code class="docutils literal notranslate"><span class="pre">particles.rigid_injected_species</span></code>.
Injection plane when using the rigid injection method.
See <code class="docutils literal notranslate"><span class="pre">particles.rigid_injected_species</span></code> above.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.rigid_advance</span></code> (<cite>bool</cite>)</dt><dd><p>Only read if <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;</span></code> is in <code class="docutils literal notranslate"><span class="pre">particles.rigid_injected_species</span></code>.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">false</span></code>, each particle is advanced with its
own velocity <code class="docutils literal notranslate"><span class="pre">vz</span></code> until it reaches <code class="docutils literal notranslate"><span class="pre">zinject_plane</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">true</span></code>, each particle is advanced with the average speed of the species
<code class="docutils literal notranslate"><span class="pre">vzbar</span></code> until it reaches <code class="docutils literal notranslate"><span class="pre">zinject_plane</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">species_name.predefined_profile_name</span></code> (<cite>string</cite>)</dt><dd><p>Only read if <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.profile</span></code> is <code class="docutils literal notranslate"><span class="pre">predefined</span></code>.</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">parabolic_channel</span></code>, the plasma profile is a parabolic profile with
cosine-like ramps at the beginning and the end of the profile.
The density is given by</p>
<div class="math notranslate nohighlight">
\[n = n_0 n(x,y) n(z-z_0)\]</div>
<p>with</p>
<div class="math notranslate nohighlight">
\[n(x,y) = 1 + 4\frac{x^2+y^2}{k_p^2 R_c^4}\]</div>
<p>where <span class="math notranslate nohighlight">\(k_p\)</span> is the plasma wavenumber associated with density <span class="math notranslate nohighlight">\(n_0\)</span>.
Here, with <span class="math notranslate nohighlight">\(z_0\)</span> as the start of the plasma, <span class="math notranslate nohighlight">\(n(z-z_0)\)</span> is a cosine-like up-ramp from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(L_{ramp,up}\)</span>,
constant to <span class="math notranslate nohighlight">\(1\)</span> from <span class="math notranslate nohighlight">\(L_{ramp,up}\)</span> to <span class="math notranslate nohighlight">\(L_{ramp,up} + L_{plateau}\)</span>
and a cosine-like down-ramp from <span class="math notranslate nohighlight">\(L_{ramp,up} + L_{plateau}\)</span> to
<span class="math notranslate nohighlight">\(L_{ramp,up} + L_{plateau}+L_{ramp,down}\)</span>. All parameters are given
in <code class="docutils literal notranslate"><span class="pre">predefined_profile_params</span></code>.</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.predefined_profile_params</span></code> (list of <cite>float</cite>)</dt><dd><p>Parameters for the predefined profiles.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">species_name.predefined_profile_name</span></code> is <code class="docutils literal notranslate"><span class="pre">parabolic_channel</span></code>,
<code class="docutils literal notranslate"><span class="pre">predefined_profile_params</span></code> contains a space-separated list of the
following parameters, in this order: <span class="math notranslate nohighlight">\(z_0\)</span> <span class="math notranslate nohighlight">\(L_{ramp,up}\)</span> <span class="math notranslate nohighlight">\(L_{plateau}\)</span>
<span class="math notranslate nohighlight">\(L_{ramp,down}\)</span> <span class="math notranslate nohighlight">\(R_c\)</span> <span class="math notranslate nohighlight">\(n_0\)</span></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_backward_propagation</span></code> (<cite>bool</cite>)</dt><dd><p>Inject a backward-propagating beam to reduce the effect of charge-separation
fields when running in the boosted frame. See examples.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.split_type</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>Splitting technique. When <cite>0</cite>, particles are split along the simulation
axes (4 particles in 2D, 6 particles in 3D). When <cite>1</cite>, particles are split
along the diagonals (4 particles in 2D, 8 particles in 3D).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_not_deposit</span></code> (<cite>0</cite> or <cite>1</cite> optional; default <cite>0</cite>)</dt><dd><p>If <cite>1</cite> is given, both charge deposition and current deposition will
not be done, thus that species does not contribute to the fields.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_not_gather</span></code> (<cite>0</cite> or <cite>1</cite> optional; default <cite>0</cite>)</dt><dd><p>If <cite>1</cite> is given, field gather from grids will not be done,
thus that species will not be affected by the field on grids.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.do_not_push</span></code> (<cite>0</cite> or <cite>1</cite> optional; default <cite>0</cite>)</dt><dd><p>If <cite>1</cite> is given, this species will not be pushed
by any pusher during the simulation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.addIntegerAttributes</span></code> (list of <cite>string</cite>)</dt><dd><p>User-defined integer particle attribute for species, <code class="docutils literal notranslate"><span class="pre">species_name</span></code>.
These integer attributes will be initialized with user-defined functions
when the particles are generated.
If the user-defined integer attribute is <code class="docutils literal notranslate"><span class="pre">&lt;int_attrib_name&gt;</span></code> then the
following required parameter must be specified to initialize the attribute.
* <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.attribute.&lt;int_attrib_name&gt;(x,y,z,ux,uy,uz,t)</span></code> (<cite>string</cite>)
<code class="docutils literal notranslate"><span class="pre">t</span></code> represents the physical time in seconds during the simulation.
<code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> represent particle positions in the unit of meter.
<code class="docutils literal notranslate"><span class="pre">ux</span></code>, <code class="docutils literal notranslate"><span class="pre">uy</span></code>, <code class="docutils literal notranslate"><span class="pre">uz</span></code> represent the particle velocities in the unit of
<span class="math notranslate nohighlight">\(\gamma v/c\)</span>, where
<span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor,
<span class="math notranslate nohighlight">\(v/c\)</span> is the particle velocity normalized by the speed of light.
E.g. If <code class="docutils literal notranslate"><span class="pre">electrons.addIntegerAttributes</span> <span class="pre">=</span> <span class="pre">upstream</span></code>
and <code class="docutils literal notranslate"><span class="pre">electrons.upstream(x,y,z,ux,uy,uz,t)</span> <span class="pre">=</span> <span class="pre">(x&gt;0.0)*1</span></code> is provided
then, an integer attribute <code class="docutils literal notranslate"><span class="pre">upstream</span></code> is added to all electron particles
and when these particles are generated, the particles with position less than <code class="docutils literal notranslate"><span class="pre">0</span></code>
are assigned a value of <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.addRealAttributes</span></code> (list of <cite>string</cite>)</dt><dd><blockquote>
<div><p>User-defined real particle attribute for species, <code class="docutils literal notranslate"><span class="pre">species_name</span></code>.
These real attributes will be initialized with user-defined functions
when the particles are generated.
If the user-defined real attribute is <code class="docutils literal notranslate"><span class="pre">&lt;real_attrib_name&gt;</span></code> then the
following required parameter must be specified to initialize the attribute.</p>
</div></blockquote>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.attribute.&lt;real_attrib_name&gt;(x,y,z,ux,uy,uz,t)</span></code> (<cite>string</cite>)
<code class="docutils literal notranslate"><span class="pre">t</span></code> represents the physical time in seconds during the simulation.
<code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> represent particle positions in the unit of meter.
<code class="docutils literal notranslate"><span class="pre">ux</span></code>, <code class="docutils literal notranslate"><span class="pre">uy</span></code>, <code class="docutils literal notranslate"><span class="pre">uz</span></code> represent the particle velocities in the unit of
<span class="math notranslate nohighlight">\(\gamma v/c\)</span>, where
<span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor,
<span class="math notranslate nohighlight">\(v/c\)</span> is the particle velocity normalized by the speed of light.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.save_particles_at_xlo/ylo/zlo</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.save_particles_at_xhi/yhi/zhi</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.save_particles_at_eb</span></code> (<cite>0</cite> or <cite>1</cite> optional, default <cite>0</cite>)</dt><dd><p>If <cite>1</cite> particles of this species will be copied to the scraped particle
buffer for the specified boundary if they leave the simulation domain in
the specified direction. <strong>If USE_EB=TRUE</strong> the <code class="docutils literal notranslate"><span class="pre">save_particles_at_eb</span></code>
flag can be set to <cite>1</cite> to also save particle data for the particles of this
species that impact the embedded boundary.
The scraped particle buffer can be used to track particle fluxes out of the
simulation.
The particle data can be written out by setting up a <code class="docutils literal notranslate"><span class="pre">BoundaryScrapingDiagnostic</span></code>.
It is also accessible via the Python interface. The
function <code class="docutils literal notranslate"><span class="pre">get_particle_boundary_buffer</span></code>, found in the
<code class="docutils literal notranslate"><span class="pre">picmi.Simulation</span></code> class as
<code class="docutils literal notranslate"><span class="pre">sim.extension.get_particle_boundary_buffer()</span></code>, can be
used to access the scraped particle buffer. An entry is included for every
particle in the buffer of the timestep at which the particle was scraped.
This can be accessed by passing the argument <code class="docutils literal notranslate"><span class="pre">comp_name=&quot;step_scraped&quot;</span></code> to
the above mentioned function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When accessing the data via Python, the scraped particle buffer relies on the user
to clear the buffer after processing the data. The
buffer will grow unbounded as particles are scraped and therefore could
lead to memory issues if not periodically cleared. To clear the buffer
call <code class="docutils literal notranslate"><span class="pre">warpx_clearParticleBoundaryBuffer()</span></code>.</p>
</div>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_field_ionization</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Do field ionization for this species (using the ADK theory).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.physical_element</span></code> (<cite>string</cite>)</dt><dd><p>Only read if <cite>do_field_ionization = 1</cite>. Symbol of chemical element for
this species. Example: for Helium, use <code class="docutils literal notranslate"><span class="pre">physical_element</span> <span class="pre">=</span> <span class="pre">He</span></code>.
All the elements up to atomic number Z=100 (Fermium) are supported.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.ionization_product_species</span></code> (<cite>string</cite>)</dt><dd><p>Only read if <cite>do_field_ionization = 1</cite>. Name of species in which ionized
electrons are stored. This species must be created as a regular species
in the input file (in particular, it must be in <cite>particles.species_names</cite>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.ionization_initial_level</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>Only read if <cite>do_field_ionization = 1</cite>. Initial ionization level of the
species (must be smaller than the atomic number of chemical element given
in <cite>physical_element</cite>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_classical_radiation_reaction</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>Enables Radiation Reaction (or Radiation Friction) for the species. Species
must be either electrons or positrons. Boris pusher must be used for the
simulation. If both <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_classical_radiation_reaction</span></code> and
<code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_qed_quantum_sync</span></code> are enabled, then the classical module
will be used when the particle’s chi parameter is below <code class="docutils literal notranslate"><span class="pre">qed_qs.chi_min</span></code>,
the discrete quantum module otherwise.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_qed_quantum_sync</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>Enables Quantum synchrotron emission for this species.
Quantum synchrotron lookup table should be either generated or loaded from disk to enable
this process (see “Lookup tables for QED modules” section below).
<cite>&lt;species&gt;</cite> must be either an electron or a positron species.
<strong>This feature requires to compile with QED=TRUE</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_qed_breit_wheeler</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>Enables non-linear Breit-Wheeler process for this species.
Breit-Wheeler lookup table should be either generated or loaded from disk to enable
this process (see “Lookup tables for QED modules” section below).
<cite>&lt;species&gt;</cite> must be a photon species.
<strong>This feature requires to compile with QED=TRUE</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.qed_quantum_sync_phot_product_species</span></code> (<cite>string</cite>)</dt><dd><p>If an electron or a positron species has the Quantum synchrotron process, a photon product species must be specified
(the name of an existing photon species must be provided)
<strong>This feature requires to compile with QED=TRUE</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.qed_breit_wheeler_ele_product_species</span></code> (<cite>string</cite>)</dt><dd><p>If a photon species has the Breit-Wheeler process, an electron product species must be specified
(the name of an existing electron species must be provided)
<strong>This feature requires to compile with QED=TRUE</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.qed_breit_wheeler_pos_product_species</span></code> (<cite>string</cite>)</dt><dd><p>If a photon species has the Breit-Wheeler process, a positron product species must be specified
(the name of an existing positron species must be provided).
<strong>This feature requires to compile with QED=TRUE</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.do_resampling</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>If <cite>1</cite> resampling is performed for this species. This means that the number of macroparticles
will be reduced at specific timesteps while preserving the distribution function as much as
possible (in particular the weight of the remaining particles will be increased on average).
This can be useful in situations with continuous creation of particles (e.g. with ionization
or with QED effects). At least one resampling trigger (see below) must be specified to actually
perform resampling.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.resampling_algorithm</span></code> (<cite>string</cite>) optional (default <cite>leveling_thinning</cite>)</dt><dd><p>The algorithm used for resampling. Currently there is only one option, which is already set by
default:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">leveling_thinning</span></code> This algorithm is defined in <a class="reference external" href="https://arxiv.org/abs/2006.08593">Muraviev et al., arXiv:2006.08593 (2020)</a>.
It has two parameters:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.resampling_algorithm_target_ratio</span></code> (<cite>float</cite>) optional (default <cite>1.5</cite>)</dt><dd><p>This <strong>roughly</strong> corresponds to the ratio between the number of particles before and
after resampling.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.resampling_algorithm_min_ppc</span></code> (<cite>int</cite>) optional (default <cite>1</cite>)</dt><dd><p>Resampling is not performed in cells with a number of macroparticles strictly smaller
than this parameter.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.resampling_trigger_intervals</span></code> (<cite>string</cite>) optional (default <cite>0</cite>)</dt><dd><p>Using the <a class="reference internal" href="#intervals-parser">Intervals parser</a> syntax, this string defines timesteps at which resampling is
performed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.resampling_trigger_max_avg_ppc</span></code> (<cite>float</cite>) optional (default <cite>infinity</cite>)</dt><dd><p>Resampling is performed everytime the number of macroparticles per cell of the species
averaged over the whole simulation domain exceeds this parameter.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="laser-initialization">
<span id="running-cpp-parameters-laser"></span><h2>Laser initialization<a class="headerlink" href="#laser-initialization" title="Link to this heading"></a></h2>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lasers.names</span></code> (list of <cite>string</cite>)</dt><dd><p>Name of each laser. This is then used in the rest of the input deck ;
in this documentation we use <cite>&lt;laser_name&gt;</cite> as a placeholder. The parameters below
must be provided for each laser pulse.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code> (<cite>3 floats in 3D and 2D</cite> ; in meters)</dt><dd><p>The coordinates of one of the point of the antenna that will emit the laser.
The plane of the antenna is entirely defined by <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code>
and <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.direction</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code> also corresponds to the origin of the coordinates system
for the laser tranverse profile. For instance, for a Gaussian laser profile,
the peak of intensity will be at the position given by <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code>.
This variable can thus be used to shift the position of the laser pulse
transversally.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In 2D, <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code> is still given by 3 numbers,
but the second number is ignored.</p>
</div>
<p>When running a <strong>boosted-frame simulation</strong>, provide the value of
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code> in the laboratory frame, and use <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code>
to automatically perform the conversion to the boosted frame. Note that,
in this case, the laser antenna will be moving, in the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.polarization</span></code> (<cite>3 floats in 3D and 2D</cite>)</dt><dd><p>The coordinates of a vector that points in the direction of polarization of
the laser. The norm of this vector is unimportant, only its direction matters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even in 2D, all the 3 components of this vectors are important (i.e.
the polarization can be orthogonal to the plane of the simulation).</p>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.direction</span></code> (<cite>3 floats in 3D</cite>)</dt><dd><p>The coordinates of a vector that points in the propagation direction of
the laser. The norm of this vector is unimportant, only its direction matters.</p>
<p>The plane of the antenna that will emit the laser is orthogonal to this vector.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>When running <strong>boosted-frame simulations</strong>, <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.direction</span></code> should
be parallel to <code class="docutils literal notranslate"><span class="pre">warpx.boost_direction</span></code>, for now.</p>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.e_max</span></code> (<cite>float</cite> ; in V/m)</dt><dd><p>Peak amplitude of the laser field.</p>
<p>For a laser with a wavelength <span class="math notranslate nohighlight">\(\lambda = 0.8\,\mu m\)</span>, the peak amplitude
is related to <span class="math notranslate nohighlight">\(a_0\)</span> by:</p>
<div class="math notranslate nohighlight">
\[E_{max} = a_0 \frac{2 \pi m_e c^2}{e\lambda} = a_0 \times (4.0 \cdot 10^{12} \;V.m^{-1})\]</div>
<p>When running a <strong>boosted-frame simulation</strong>, provide the value of <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.e_max</span></code>
in the laboratory frame, and use <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code> to automatically
perform the conversion to the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.a0</span></code> (<cite>float</cite> ; dimensionless)</dt><dd><p>Peak normalized amplitude of the laser field (given in the lab frame, just as <code class="docutils literal notranslate"><span class="pre">e_max</span></code> above).
See the description of <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.e_max</span></code> for the conversion between <code class="docutils literal notranslate"><span class="pre">a0</span></code> and <code class="docutils literal notranslate"><span class="pre">e_max</span></code>.
Exactly one of <code class="docutils literal notranslate"><span class="pre">a0</span></code> and <code class="docutils literal notranslate"><span class="pre">e_max</span></code> must be specified.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.wavelength</span></code> (<cite>float</cite>; in meters)</dt><dd><p>The wavelength of the laser in vacuum.</p>
<p>When running a <strong>boosted-frame simulation</strong>, provide the value of
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.wavelength</span></code> in the laboratory frame, and use <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code>
to automatically perform the conversion to the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile</span></code> (<cite>string</cite>)</dt><dd><p>The spatio-temporal shape of the laser. The options that are currently
implemented are:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Gaussian&quot;</span></code>: The transverse and longitudinal profiles are Gaussian.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Harris&quot;</span></code>: The transverse profile is Gaussian, but the longitudinal profile
is given by the Harris function (see <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_duration</span></code> for more details)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;parse_field_function&quot;</span></code>: the laser electric field is given by a function in the
input file. It requires additional argument <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.field_function(X,Y,t)</span></code>, which
is a mathematical expression , e.g.
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.field_function(X,Y,t)</span> <span class="pre">=</span> <span class="pre">&quot;a0*X**2</span> <span class="pre">*</span> <span class="pre">(X&gt;0)</span> <span class="pre">*</span> <span class="pre">cos(omega0*t)&quot;</span></code> where
<code class="docutils literal notranslate"><span class="pre">a0</span></code> and <code class="docutils literal notranslate"><span class="pre">omega0</span></code> are a user-defined constant, see above. The profile passed
here is the full profile, not only the laser envelope. <code class="docutils literal notranslate"><span class="pre">t</span></code> is time and <code class="docutils literal notranslate"><span class="pre">X</span></code>
and <code class="docutils literal notranslate"><span class="pre">Y</span></code> are coordinates orthogonal to <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.direction</span></code> (not necessarily the
x and y coordinates of the simulation). All parameters above are required, but
none of the parameters below are used when <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.parse_field_function=1</span></code>. Even
though <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.wavelength</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.e_max</span></code> should be included in the laser
function, they still have to be specified as they are used for numerical purposes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;from_txye_file&quot;</span></code>: the electric field of the laser is read from an external binary file
whose format is explained below. It requires to provide the name of the binary file
setting the additional parameter <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.txye_file_name</span></code> (<cite>string</cite>). It accepts an
optional parameter <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.time_chunk_size</span></code> (<cite>int</cite>). This allows to read only
time_chunk_size timesteps from the binary file. New timesteps are read as soon as they are needed.
The default value is automatically set to the number of timesteps contained in the binary file
(i.e. only one read is performed at the beginning of the simulation).
It also accepts the optional parameter <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.delay</span></code> (<cite>float</cite>; in seconds), which allows
delaying (<code class="docutils literal notranslate"><span class="pre">delay</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>) or anticipating (<code class="docutils literal notranslate"><span class="pre">delay</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>) the laser by the specified amount of time.
The external binary file should provide E(x,y,t) on a rectangular (but non necessarily uniform)
grid. The code performs a bi-linear (in 2D) or tri-linear (in 3D) interpolation to set the field
values. x,y,t are meant to be in S.I. units, while the field value is meant to be multiplied by
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.e_max</span></code> (i.e. in most cases the maximum of abs(E(x,y,t)) should be 1,
so that the maximum field intensity can be set straightforwardly with <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.e_max</span></code>).
The binary file has to respect the following format:</p>
<blockquote>
<div><ul class="simple">
<li><p>flag to indicate if the grid is uniform or not (1 byte, 0 means non-uniform, !=0 means uniform)</p></li>
<li><p>np, number of timesteps (uint32_t, must be &gt;=2)</p></li>
<li><p>nx, number of points along x (uint32_t, must be &gt;=2)</p></li>
<li><p>ny, number of points along y (uint32_t, must be 1 for 2D simulations and &gt;=2 for 3D simulations)</p></li>
<li><p>timesteps (double[2] if grid is uniform, double[np] otherwise)</p></li>
<li><p>x_coords (double[2] if grid is uniform, double[nx] otherwise)</p></li>
<li><p>y_coords (double[1] if 2D, double[2] if 3D &amp; uniform grid, double[ny] if 3D &amp; non uniform grid)</p></li>
<li><p>field_data (double[nt * nx * ny], with nt being the slowest coordinate).</p></li>
</ul>
</div></blockquote>
<p>A file at this format can be generated from Python, see an example at <code class="docutils literal notranslate"><span class="pre">Examples/Tests/laser_injection_from_file</span></code></p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_t_peak</span></code> (<cite>float</cite>; in seconds)</dt><dd><p>The time at which the laser reaches its peak intensity, at the position
given by <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.position</span></code> (only used for the <code class="docutils literal notranslate"><span class="pre">&quot;gaussian&quot;</span></code> profile)</p>
<p>When running a <strong>boosted-frame simulation</strong>, provide the value of
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_t_peak</span></code> in the laboratory frame, and use <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code>
to automatically perform the conversion to the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_duration</span></code> (<cite>float</cite> ; in seconds)</dt><dd><p>The duration of the laser pulse, defined as <span class="math notranslate nohighlight">\(\tau\)</span> below:</p>
<ul class="simple">
<li><p>For the <code class="docutils literal notranslate"><span class="pre">&quot;gaussian&quot;</span></code> profile:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[E(\boldsymbol{x},t) \propto \exp\left( -\frac{(t-t_{peak})^2}{\tau^2} \right)\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\tau\)</span> relates to the full width at half maximum (FWHM) of <em>intensity</em>, which is closer to pulse length measurements in experiments, as <span class="math notranslate nohighlight">\(\tau = \mathrm{FWHM}_I / \sqrt{2\ln(2)}\)</span> <span class="math notranslate nohighlight">\(\approx \mathrm{FWHM}_I / 1.174\)</span>.</p>
<ul class="simple">
<li><p>For the <code class="docutils literal notranslate"><span class="pre">&quot;harris&quot;</span></code> profile:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[E(\boldsymbol{x},t) \propto \frac{1}{32}\left[10 - 15 \cos\left(\frac{2\pi t}{\tau}\right) + 6 \cos\left(\frac{4\pi t}{\tau}\right) - \cos\left(\frac{6\pi t}{\tau}\right) \right]\Theta(\tau - t)\]</div>
<p>When running a <strong>boosted-frame simulation</strong>, provide the value of
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_duration</span></code> in the laboratory frame, and use <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code>
to automatically perform the conversion to the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_waist</span></code> (<cite>float</cite> ; in meters)</dt><dd><p>The waist of the transverse Gaussian laser profile, defined as <span class="math notranslate nohighlight">\(w_0\)</span> :</p>
<div class="math notranslate nohighlight">
\[E(\boldsymbol{x},t) \propto \exp\left( -\frac{\boldsymbol{x}_\perp^2}{w_0^2} \right)\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_focal_distance</span></code> (<cite>float</cite>; in meters)</dt><dd><p>The distance from <code class="docutils literal notranslate"><span class="pre">laser_position</span></code> to the focal plane.
(where the distance is defined along the direction given by <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.direction</span></code>.)</p>
<p>Use a negative number for a defocussing laser instead of a focussing laser.</p>
<p>When running a <strong>boosted-frame simulation</strong>, provide the value of
<code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.profile_focal_distance</span></code> in the laboratory frame, and use <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code>
to automatically perform the conversion to the boosted frame.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.phi0</span></code> (<cite>float</cite>; in radians) optional (default <cite>0.</cite>)</dt><dd><p>The Carrier Envelope Phase, i.e. the phase of the laser oscillation, at the
position where the laser envelope is maximum (only used for the <code class="docutils literal notranslate"><span class="pre">&quot;gaussian&quot;</span></code> profile)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.stc_direction</span></code> (<cite>3 floats</cite>) optional (default <cite>1. 0. 0.</cite>)</dt><dd><p>Direction of laser spatio-temporal couplings.
See definition in Akturk et al., Opt Express, vol 12, no 19 (2004).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.zeta</span></code> (<cite>float</cite>; in meters.seconds) optional (default <cite>0.</cite>)</dt><dd><p>Spatial chirp at focus in direction <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.stc_direction</span></code>. See definition in
Akturk et al., Opt Express, vol 12, no 19 (2004).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.beta</span></code> (<cite>float</cite>; in seconds) optional (default <cite>0.</cite>)</dt><dd><p>Angular dispersion (or angular chirp) at focus in direction <code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.stc_direction</span></code>.
See definition in Akturk et al., Opt Express, vol 12, no 19 (2004).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.phi2</span></code> (<cite>float</cite>; in seconds**2) optional (default <cite>0.</cite>)</dt><dd><p>Temporal chirp at focus.
See definition in Akturk et al., Opt Express, vol 12, no 19 (2004).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.do_continuous_injection</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>).</dt><dd><p>Whether or not to use continuous injection.
If the antenna starts outside of the simulation domain but enters it
at some point (due to moving window or moving antenna in the boosted
frame), use this so that the laser antenna is injected when it reaches
the box boundary. If running in a boosted frame, this requires the
boost direction, moving window direction and laser propagation direction
to be along <cite>z</cite>. If not running in a boosted frame, this requires the
moving window and laser propagation directions to be the same (<cite>x</cite>, <cite>y</cite>
or <cite>z</cite>)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;laser_name&gt;.min_particles_per_mode</span></code> (<cite>int</cite>) optional (default <cite>4</cite>)</dt><dd><p>When using the RZ version, this specifies the minimum number of particles
per angular mode. The laser particles are loaded into radial spokes, with
the number of spokes given by min_particles_per_mode*(warpx.n_rz_azimuthal_modes-1).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lasers.deposit_on_main_grid</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>When using mesh refinement, whether the antenna that emits the laser
deposits charge/current only on the main grid (i.e. level 0), or also
on the higher mesh-refinement levels.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.num_mirrors</span></code> (<cite>int</cite>) optional (default <cite>0</cite>)</dt><dd><p>Users can input perfect mirror condition inside the simulation domain.
The number of mirrors is given by <code class="docutils literal notranslate"><span class="pre">warpx.num_mirrors</span></code>. The mirrors are
orthogonal to the <cite>z</cite> direction. The following parameters are required
when <code class="docutils literal notranslate"><span class="pre">warpx.num_mirrors</span></code> is &gt;0.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mirror_z</span></code> (list of <cite>float</cite>) required if <code class="docutils literal notranslate"><span class="pre">warpx.num_mirrors&gt;0</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">z</span></code> location of the front of the mirrors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mirror_z_width</span></code> (list of <cite>float</cite>) required if <code class="docutils literal notranslate"><span class="pre">warpx.num_mirrors&gt;0</span></code></dt><dd><p><code class="docutils literal notranslate"><span class="pre">z</span></code> width of the mirrors.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mirror_z_npoints</span></code> (list of <cite>int</cite>) required if <code class="docutils literal notranslate"><span class="pre">warpx.num_mirrors&gt;0</span></code></dt><dd><p>In the boosted frame, depending on <cite>gamma_boost</cite>, <code class="docutils literal notranslate"><span class="pre">warpx.mirror_z_width</span></code>
can be smaller than the cell size, so that the mirror would not work. This
parameter is the minimum number of points for the mirror. If
<code class="docutils literal notranslate"><span class="pre">mirror_z_width</span> <span class="pre">&lt;</span> <span class="pre">dz/cell_size</span></code>, the upper bound of the mirror is increased
so that it contains at least <code class="docutils literal notranslate"><span class="pre">mirror_z_npoints</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="external-fields">
<h2>External fields<a class="headerlink" href="#external-fields" title="Link to this heading"></a></h2>
<section id="grid-initialization">
<h3>Grid initialization<a class="headerlink" href="#grid-initialization" title="Link to this heading"></a></h3>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.B_ext_grid_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the external
magnetic field. The “default” style initializes the
external magnetic field (Bx,By,Bz) to (0.0, 0.0, 0.0).
The string can be set to “constant” if a constant magnetic field is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">warpx.B_external_grid</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_B_ext_grid_function</span></code>, then a mathematical expression can
be used to initialize the external magnetic field on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Bx_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.By_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Bz_external_grid_function(x,y,z)</span></code> to initialize the external
magnetic field for each of the three components on the grid.
Constants required in the expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
For example, if <code class="docutils literal notranslate"><span class="pre">warpx.Bx_external_grid_function(x,y,z)=Bo*x</span> <span class="pre">+</span> <span class="pre">delta*(y</span> <span class="pre">+</span> <span class="pre">z)</span></code>
then the constants <cite>Bo</cite> and <cite>delta</cite> required in the above equation
can be set using <code class="docutils literal notranslate"><span class="pre">my_constants.Bo=</span></code> and <code class="docutils literal notranslate"><span class="pre">my_constants.delta=</span></code> in the
input file. For a two-dimensional simulation, it is assumed that the first dimension
is <cite>x</cite> and the second dimension is <cite>z</cite>, and the value of <cite>y</cite> is set to zero.
Note that the current implementation of the parser for external B-field
does not work with RZ and the code will abort with an error message.
Note that the implementation of the parser for external B-field does not work
with USE_LLG=TRUE and the code will abort with an error message</p>
<p>If <code class="docutils literal notranslate"><span class="pre">B_ext_grid_init_style</span></code> is set to be <code class="docutils literal notranslate"><span class="pre">read_from_file</span></code>, an additional parameter,
indicating the path of an openPMD data file,
<code class="docutils literal notranslate"><span class="pre">warpx.read_fields_from_path</span></code> must be specified,
from which external B field data can be loaded into WarpX.
One can refer to input files in <code class="docutils literal notranslate"><span class="pre">Examples/Tests/LoadExternalField</span></code> for more information.
Regarding how to prepare the openPMD data file, one can refer to
the <a class="reference external" href="https://github.com/openPMD/openPMD-example-datasets">openPMD-example-datasets</a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.E_ext_grid_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the external
electric field. The “default” style initializes the
external electric field (Ex,Ey,Ez) to (0.0, 0.0, 0.0).
The string can be set to “constant” if a constant electric field is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">warpx.E_external_grid</span></code> must be specified
in the input file.
If set to <code class="docutils literal notranslate"><span class="pre">parse_E_ext_grid_function</span></code>, then a mathematical expression can
be used to initialize the external electric field on the grid. It
required additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Ex_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ey_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ez_external_grid_function(x,y,z)</span></code> to initialize the external
electric field for each of the three components on the grid.
Constants required in the expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
For example, if <code class="docutils literal notranslate"><span class="pre">warpx.Ex_external_grid_function(x,y,z)=Eo*x</span> <span class="pre">+</span> <span class="pre">delta*(y</span> <span class="pre">+</span> <span class="pre">z)</span></code>
then the constants <cite>Bo</cite> and <cite>delta</cite> required in the above equation
can be set using <code class="docutils literal notranslate"><span class="pre">my_constants.Eo=</span></code> and <code class="docutils literal notranslate"><span class="pre">my_constants.delta=</span></code> in the
input file. For a two-dimensional simulation, it is assumed that the first
dimension is <cite>x</cite> and the second dimension is <cite>z</cite>,
and the value of <cite>y</cite> is set to zero.
Note that the current implementation of the parser for external E-field
does not work with RZ and the code will abort with an error message.
If <code class="docutils literal notranslate"><span class="pre">E_ext_grid_init_style</span></code> is set to be <code class="docutils literal notranslate"><span class="pre">read_from_file</span></code>, an additional parameter,
indicating the path of an openPMD data file,
<code class="docutils literal notranslate"><span class="pre">warpx.read_fields_from_path</span></code> must be specified,
from which external E field data can be loaded into WarpX.
One can refer to input files in <code class="docutils literal notranslate"><span class="pre">Examples/Tests/LoadExternalField</span></code> for more information.
Regarding how to prepare the openPMD data file, one can refer to
the <a class="reference external" href="https://github.com/openPMD/openPMD-example-datasets">openPMD-example-datasets</a>.
Note that if both <cite>B_ext_grid_init_style</cite> and <cite>E_ext_grid_init_style</cite> are set to
<cite>read_from_file</cite>, the openPMD file specified by <cite>warpx.read_fields_from_path</cite>
should contain both B and E external fields data.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.H_ext_grid_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the external
magnetic field intensity. The “default” style initializes the
external magnetic field (Hx,Hy,Hz) to (0.0, 0.0, 0.0).
The string can be set to “constant” if a constant magnetic field is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">warpx.H_external_grid</span></code> must be specified
in the input file.
If set to <code class="docutils literal notranslate"><span class="pre">parse_H_ext_grid_function</span></code>, then a mathematical expression can
be used to initialize the external magnetic field on the grid. It
required additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Hx_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hy_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hz_external_grid_function(x,y,z)</span></code> to initialize the external
magnetic field intensity for each of the three components on the grid.
Constants required in the expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
For example, if <code class="docutils literal notranslate"><span class="pre">warpx.Hx_external_grid_function(x,y,z)=Ho*x</span> <span class="pre">+</span> <span class="pre">delta*(y</span> <span class="pre">+</span> <span class="pre">z)</span></code>
then the constants <cite>Ho</cite> and <cite>delta</cite> required in the above equation
can be set using <code class="docutils literal notranslate"><span class="pre">my_constants.Ho=</span></code> and <code class="docutils literal notranslate"><span class="pre">my_constants.delta=</span></code> in the
input file. This function is currently supported only for 3D simulations.
Note that the current implementation of the parser for external H-field
does not work with RZ and the code will abort with an error message.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.E_external_grid</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">warpx.B_external_grid</span></code> (list of <cite>3 floats</cite>)</dt><dd><p>required when <code class="docutils literal notranslate"><span class="pre">warpx.E_ext_grid_init_style=&quot;constant&quot;</span></code>
and when <code class="docutils literal notranslate"><span class="pre">warpx.B_ext_grid_init_style=&quot;constant&quot;</span></code>, respectively.
External uniform and constant electrostatic and magnetostatic field added
to the grid at initialization. Use with caution as these fields are used for
the field solver. In particular, do not use any other boundary condition
than periodic.
Note that the implementation of the parser for external B-field does not work
with USE_LLG=TRUE and the code will abort with an error message</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.H_external_grid</span></code> (list of <cite>3 floats</cite>)</dt><dd><p>required when <code class="docutils literal notranslate"><span class="pre">warpx.H_ext_grid_init_style=&quot;constant&quot;</span></code>.
External uniform and constant magnetostatic field added
to the grid at initialization. Use with caution as these fields are used for
the field solver. In particular, do not use any other boundary condition
than periodic.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="applied-to-particles">
<h3>Applied to Particles<a class="headerlink" href="#applied-to-particles" title="Link to this heading"></a></h3>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">particles.E_ext_particle_init_style</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">particles.B_ext_particle_init_style</span></code> (string) optional (default “none”)</dt><dd><p>These parameters determine the type of the external electric and
magnetic fields respectively that are applied directly to the particles at every timestep.
The field values are specified in the lab frame.
With the default <code class="docutils literal notranslate"><span class="pre">none</span></code> style, no field is applied.
Possible values are <code class="docutils literal notranslate"><span class="pre">constant</span></code>, <code class="docutils literal notranslate"><span class="pre">parse_E_ext_particle_function</span></code> or <code class="docutils literal notranslate"><span class="pre">parse_B_ext_particle_function</span></code>, or
<code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">constant</span></code>: a constant field is applied, given by the input parameters
<code class="docutils literal notranslate"><span class="pre">particles.E_external_particle</span></code> or <code class="docutils literal notranslate"><span class="pre">particles.B_external_particle</span></code>, which are lists of the field components.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">parse_E_ext_particle_function</span></code> or <code class="docutils literal notranslate"><span class="pre">parse_B_ext_particle_function</span></code>: the field is specified as an analytic
expression that is a function of space (x,y,z) and time (t), relative to the lab frame.
The E-field is specified by the input parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">particles.Ex_external_particle_function(x,y,z,t)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">particles.Ey_external_particle_function(x,y,z,t)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">particles.Ez_external_particle_function(x,y,z,t)</span></code></p></li>
</ul>
</div></blockquote>
<p>The B-field is specified by the input parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">particles.Bx_external_particle_function(x,y,z,t)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">particles.By_external_particle_function(x,y,z,t)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">particles.Bz_external_particle_function(x,y,z,t)</span></code></p></li>
</ul>
</div></blockquote>
<p>Note that the position is defined in Cartesian coordinates, as a function of (x,y,z), even for RZ.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens</span></code>: apply a series of plasma lenses. The properties of the lenses are defined in the
lab frame by the input parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens_period</span></code>, the period length of the repeat, a single float number,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens_starts</span></code>, the start of each lens relative to the period, an array of floats,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens_lengths</span></code>, the length of each lens, an array of floats,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens_strengths_E</span></code>, the electric focusing strength of each lens, an array of floats, when
<code class="docutils literal notranslate"><span class="pre">particles.E_ext_particle_init_style</span></code> is set to <code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens_strengths_B</span></code>, the magnetic focusing strength of each lens, an array of floats, when
<code class="docutils literal notranslate"><span class="pre">particles.B_ext_particle_init_style</span></code> is set to <code class="docutils literal notranslate"><span class="pre">repeated_plasma_lens</span></code>.</p></li>
</ul>
</div></blockquote>
<p>The applied field is uniform longitudinally (along z) with a hard edge,
where residence corrections are used for more accurate field calculation. On the time step when a particle enters
or leaves each lens, the field applied is scaled by the fraction of the time step spent within the lens.
The fields are of the form <span class="math notranslate nohighlight">\(E_x = \mathrm{strength} \cdot x\)</span>, <span class="math notranslate nohighlight">\(E_y = \mathrm{strength} \cdot y\)</span>,
and <span class="math notranslate nohighlight">\(E_z = 0\)</span>, and
<span class="math notranslate nohighlight">\(B_x = \mathrm{strength} \cdot y\)</span>, <span class="math notranslate nohighlight">\(B_y = -\mathrm{strength} \cdot x\)</span>, and <span class="math notranslate nohighlight">\(B_z = 0\)</span>.</p>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">B_excitation_on_grid_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter is used to set the type of external magnetic field excitation
varying in space (x,y,z) and time (t). The excitation is added to the magnetic field
on the grid at every timestep. To add an external B-excitation as a function
of (x,y,z,t), use the option <code class="docutils literal notranslate"><span class="pre">parse_B_excitation_grid_function</span></code>. This option requires
additional parameters in the input file to set the parser function, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Bx_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.By_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Bz_excitation_grid_function(x,y,z,t)</span></code> to apply the external B-field on the grid.
Additionally, the option also requires a flag function to set the type of excitation,
<code class="docutils literal notranslate"><span class="pre">warpx.Bx_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.By_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Bz_excitation_flag_function(x,y,z)</span></code>. This spatially varying function can be
set to have three values, namely 0, 1, or 2.
If the flag is set to 0 at a given <cite>(x,y,z)</cite>, then the excitation is not applied to the
field component at that location.
If the flag is set to 1 at a given <cite>(x,y,z)</cite>, then the excitation is treated as a hard
source and the field component at that location is set exactly equal to the value
from the <cite>excitation_grid_function</cite> of the corresponding field component.
If the flag is set to 2, then the excittaion is treated as a soft source and the
field component is updated with the contribution from the <cite>excitation_grid_function</cite>
of the corresponding field component.
Constants required in the mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
This function is currently supported only for 3D simulations.
Note that the implementation of the parser for excitation B-field does not work
with LLG and the code will abort with an error message</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">E_excitation_on_grid_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter is used to set the type of external electric field excitation
varying in space (x,y,z) and time (t). The excitation is added to the electric field
on the grid at every timestep. To add an external E-excitation as a function
of (x,y,z,t), use the option <code class="docutils literal notranslate"><span class="pre">parse_E_excitation_grid_function</span></code>. This option requires
additional parameters in the input file to set the parser function, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Ex_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ey_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ez_excitation_grid_function(x,y,z,t)</span></code> to apply the external E-field on the grid.
Additionally, the option also requires a flag function to set the type of excitation,
<code class="docutils literal notranslate"><span class="pre">warpx.Ex_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ey_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ez_excitation_flag_function(x,y,z)</span></code>. This spatially varying function can be
set to have three values, namely 0, 1, or 2.
If the flag is set to 0 at a given <cite>(x,y,z)</cite>, then the excitation is not applied to the
field component at that location.
If the flag is set to 1 at a given <cite>(x,y,z)</cite>, then the excitation is treated as a hard
source and the field component at that location is set exactly equal to the value
from the <cite>excitation_grid_function</cite> of the corresponding field component.
If the flag is set to 2, then the excittaion is treated as a soft source and the
field component is updated with the contribution from the <cite>excitation_grid_function</cite>
of the corresponding field component.
Constants required in the mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
This function is currently supported only for 3D simulations and only for single-level simulations.
Note that by default the parser applies these functions to the electric fields only in the valid region
or in the regions specified by the user-defined parser.
The same function can also be applied to the fields in the pml region by setting
<code class="docutils literal notranslate"><span class="pre">warpx.Apply_E_excitation_in_pml_region</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Apply_E_excitation_in_pml_region</span></code> (integer <cite>0</cite> or <cite>1</cite>) optional (default is <cite>0</cite>)</dt><dd><p>This parameter is used only if <cite>E_excitation_on_grid_style</cite> is set in the input.
If set to <cite>1</cite>, the excitation function for Ex, Ey, Ez set using
<code class="docutils literal notranslate"><span class="pre">warpx.Ex_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ey_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Ez_excitation_grid_function(x,y,z,t)</span></code> will be applied to the electric fields defined
in the pml region. Note that, the pml region is set outside the domain boundary.
So for this feature to work as intended, it is essential that the parser function covers the pml
region.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">H_excitation_on_grid_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter is used to set the type of external magnetic field excitation
varying in space (x,y,z) and time (t). The excitation is added to the magnetic field
on the grid at every timestep. To add an external H-excitation as a function
of (x,y,z,t), use the option <code class="docutils literal notranslate"><span class="pre">parse_H_excitation_grid_function</span></code>. This option requires
additional parameters in the input file to set the parser function, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Hx_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hy_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hz_excitation_grid_function(x,y,z,t)</span></code> to apply the external H-field on the grid.
Additionally, the option also requires a flag function to set the type of excitation,
<code class="docutils literal notranslate"><span class="pre">warpx.Hx_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hy_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hz_excitation_flag_function(x,y,z)</span></code>. This spatially varying function can be
set to have three values, namely 0, 1, or 2.
If the flag is set to 0 at a given <cite>(x,y,z)</cite>, then the excitation is not applied to the
field component at that location.
If the flag is set to 1 at a given <cite>(x,y,z)</cite>, then the excitation is treated as a hard
source and the field component at that location is set exactly equal to the value
from the <cite>excitation_grid_function</cite> of the corresponding field component.
If the flag is set to 2, then the excittaion is treated as a soft source and the
field component is updated with the contribution from the <cite>excitation_grid_function</cite>
of the corresponding field component.
Constants required in the mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
This function is currently supported only for 3D simulations.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">H_bias_excitation_on_grid_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter is used to set the type of external magnetic bias field
varying in space (x,y,z) and time (t). It should be noted that
physically H_bias is constant in time, but one can model one-way coupling of the EM field
with the magnetization field by including a time-dependent component.
The excitation is added to the magnetic bias field
on the grid at every timestep. To add an external H-bias-excitation as a function
of (x,y,z,t), use the option <code class="docutils literal notranslate"><span class="pre">parse_h_bias_excitation_grid_function</span></code>. This option requires
additional parameters in the input file to set the parser function, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Hx_bias_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hy_bias_excitation_grid_function(x,y,z,t)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hz_bias_excitation_grid_function(x,y,z,t)</span></code> to apply the external H-bias-field on the grid.
Additionally, the option also requires a flag function to set the type of excitation,
<code class="docutils literal notranslate"><span class="pre">warpx.Hx_bias_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hy_bias_excitation_flag_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hz_bias_excitation_flag_function(x,y,z)</span></code>. This spatially varying function can be
set to have three values, namely 0, 1, or 2.
If the flag is set to 0 at a given <cite>(x,y,z)</cite>, then the excitation is not applied to the
field component at that location.
If the flag is set to 1 at a given <cite>(x,y,z)</cite>, then the excitation is treated as a hard
source and the field component at that location is set exactly equal to the value
from the <cite>excitation_grid_function</cite> of the corresponding field component.
If the flag is set to 2, then the excittaion is treated as a soft source and the
field component is updated with the contribution from the <cite>excitation_grid_function</cite>
of the corresponding field component.
Constants required in the mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
This function is currently supported only for 3D simulations.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="accelerator-lattice">
<h3>Accelerator Lattice<a class="headerlink" href="#accelerator-lattice" title="Link to this heading"></a></h3>
<p>Several accelerator lattice elements can be defined as described below.
The elements are defined relative to the <cite>z</cite> axis and in the lab frame, starting at <cite>z = 0</cite>.
They are described using a simplified MAD like syntax.
Note that elements of the same type cannot overlap each other.</p>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lattice.elements</span></code> (<code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">of</span> <span class="pre">strings</span></code>) optional (default: no elements)</dt><dd><p>A list of names (one name per lattice element), in the order that they
appear in the lattice.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">lattice.reverse</span></code> (<code class="docutils literal notranslate"><span class="pre">boolean</span></code>) optional (default: <code class="docutils literal notranslate"><span class="pre">false</span></code>)</dt><dd><p>Reverse the list of elements in the lattice.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.type</span></code> (<code class="docutils literal notranslate"><span class="pre">string</span></code>)</dt><dd><p>Indicates the element type for this lattice element. This should be one of:</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">drift</span></code> for free drift. This requires this additional parameter:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.ds</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in meters) the segment length</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">quad</span></code> for a hard edged quadrupole.
This applies a quadrupole field that is uniform within the <cite>z</cite> extent of the element with a sharp cut off at the ends.
This uses residence corrections, with the field scaled by the amount of time within the element for particles entering
or leaving it, to increase the accuracy.
This requires these additional parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.ds</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in meters) the segment length</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.dEdx</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in volts/meter^2) optional (default: 0.) the electric quadrupole field gradient
The field applied to the particles will be <cite>Ex = dEdx*x</cite> and <cite>Ey = -dEdx*y</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.dBdx</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in Tesla/meter) optional (default: 0.) the magnetic quadrupole field gradient
The field applied to the particles will be <cite>Bx = dBdx*y</cite> and <cite>By = dBdx*x</cite>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">plasmalens</span></code> for a field modeling a plasma lens
This applies a radially directed plasma lens field that is uniform within the <cite>z</cite> extent of the element with
a sharp cut off at the ends.
This uses residence corrections, with the field scaled by the amount of time within the element for particles entering
or leaving it, to increase the accuracy.
This requires these additional parameters:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.ds</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in meters) the segment length</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.dEdx</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in volts/meter^2) optional (default: 0.) the electric field gradient
The field applied to the particles will be <cite>Ex = dEdx*x</cite> and <cite>Ey = dEdx*y</cite>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.dBdx</span></code> (<code class="docutils literal notranslate"><span class="pre">float</span></code>, in Tesla/meter) optional (default: 0.) the magnetic field gradient
The field applied to the particles will be <cite>Bx = dBdx*y</cite> and <cite>By = -dBdx*x</cite>.</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">line</span></code> a sub-lattice (line) of elements to append to the lattice.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.elements</span></code> (<code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">of</span> <span class="pre">strings</span></code>) optional (default: no elements)
A list of names (one name per lattice element), in the order that they appear in the lattice.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;element_name&gt;.reverse</span></code> (<code class="docutils literal notranslate"><span class="pre">boolean</span></code>) optional (default: <code class="docutils literal notranslate"><span class="pre">false</span></code>)
Reverse the list of elements in the line before appending to the lattice.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<section id="collision-models">
<span id="running-cpp-parameters-collision"></span><h2>Collision models<a class="headerlink" href="#collision-models" title="Link to this heading"></a></h2>
<p>WarpX provides several particle collision models, using varying degrees of approximation.</p>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">collisions.collision_names</span></code> (<cite>strings</cite>, separated by spaces)</dt><dd><p>The name of each collision type.
This is then used in the rest of the input deck;
in this documentation we use <code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;</span></code> as a placeholder.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.type</span></code> (<cite>string</cite>) optional</dt><dd><p>The type of collision. The types implemented are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pairwisecoulomb</span></code> for pairwise Coulomb collisions, the default if unspecified.
This provides a pair-wise relativistic elastic Monte Carlo binary Coulomb collision model,
following the algorithm given by <a class="reference external" href="https://doi.org/10.1063/1.4742167">Perez et al. (Phys. Plasmas 19, 083104, 2012)</a>.
When the RZ mode is used, <cite>warpx.n_rz_azimuthal_modes</cite> must be set to 1 at the moment,
since the current implementation of the collision module assumes axisymmetry.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nuclearfusion</span></code> for fusion reactions.
This implements the pair-wise fusion model by <a class="reference external" href="https://doi.org/10.1016/j.jcp.2019.03.020">Higginson et al. (JCP 388, 439-453, 2019)</a>.
Currently, WarpX supports deuterium-deuterium, deuterium-tritium, deuterium-helium and proton-boron fusion.
When initializing the reactant and product species, you need to use <code class="docutils literal notranslate"><span class="pre">species_type</span></code> (see the documentation
for this parameter), so that WarpX can identify the type of reaction to use.
(e.g. <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;.species_type</span> <span class="pre">=</span> <span class="pre">'deuterium'</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">background_mcc</span></code> for collisions between particles and a neutral background.
This is a relativistic Monte Carlo treatment for particles colliding
with a neutral background gas. The implementation follows the so-called
null collision strategy discussed for example in <a class="reference external" href="https://ieeexplore.ieee.org/document/106800">Birdsall (IEEE Transactions on
Plasma Science, vol. 19, no. 2, pp. 65-85, 1991)</a>.
See also <a class="reference internal" href="../theory/collisions.html#theory-collisions"><span class="std std-ref">collisions section</span></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">background_stopping</span></code> for slowing of ions due to collisions with electrons or ions.
This implements the approximate formulae as derived in Introduction to Plasma Physics,
from Goldston and Rutherford, section 14.2.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.species</span></code> (<cite>strings</cite>)</dt><dd><p>If using <code class="docutils literal notranslate"><span class="pre">pairwisecoulomb</span></code> or <code class="docutils literal notranslate"><span class="pre">nuclearfusion</span></code>, this should be the name(s) of the species,
between which the collision will be considered. (Provide only one name for intra-species collisions.)
If using <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code> or <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code> type this should be the name of the
species for which collisions with a background will be included.
In this case, only one species name should be given.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.product_species</span></code> (<cite>strings</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">nuclearfusion</span></code>. The name(s) of the species in which to add
the new macroparticles created by the reaction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.ndt</span></code> (<cite>int</cite>) optional</dt><dd><p>Execute collision every # time steps. The default value is 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.CoulombLog</span></code> (<cite>float</cite>) optional</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">pairwisecoulomb</span></code>. A provided fixed Coulomb logarithm of the
collision type <code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;</span></code>.
For example, a typical Coulomb logarithm has a form of
<span class="math notranslate nohighlight">\(\ln(\lambda_D/R)\)</span>,
where <span class="math notranslate nohighlight">\(\lambda_D\)</span> is the Debye length,
<span class="math notranslate nohighlight">\(R\approx1.4A^{1/3}\)</span> is the effective Coulombic radius of the nucleus,
<span class="math notranslate nohighlight">\(A\)</span> is the mass number.
If this is not provided, or if a non-positive value is provided,
a Coulomb logarithm will be computed automatically according to the algorithm in
<a class="reference external" href="https://doi.org/10.1063/1.4742167">Perez et al. (Phys. Plasmas 19, 083104, 2012)</a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.fusion_multiplier</span></code> (<cite>float</cite>) optional.</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">nuclearfusion</span></code>.
Increasing <code class="docutils literal notranslate"><span class="pre">fusion_multiplier</span></code> creates more macroparticles of fusion
products, but with lower weight (in such a way that the corresponding
total number of physical particle remains the same). This can improve
the statistics of the simulation, in the case where fusion reactions are very rare.
More specifically, in a fusion reaction between two macroparticles with weight <code class="docutils literal notranslate"><span class="pre">w_1</span></code> and <code class="docutils literal notranslate"><span class="pre">w_2</span></code>,
the weight of the product macroparticles will be <code class="docutils literal notranslate"><span class="pre">min(w_1,w_2)/fusion_multipler</span></code>.
(And the weights of the reactant macroparticles are reduced correspondingly after the reaction.)
See <a class="reference external" href="https://doi.org/10.1016/j.jcp.2019.03.020">Higginson et al. (JCP 388, 439-453, 2019)</a>
for more details. The default value of <code class="docutils literal notranslate"><span class="pre">fusion_multiplier</span></code> is 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a href="#id1"><span class="problematic" id="id2">``</span></a>&lt;collision_name&gt;.fusion_probability_threshold``(<cite>float</cite>) optional.</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">nuclearfusion</span></code>.
If the fusion multiplier is too high and results in a fusion probability
that approaches 1 (for a given collision between two macroparticles), then
there is a risk of underestimating the total fusion yield. In these cases,
WarpX reduces the fusion multiplier used in that given collision.
<code class="docutils literal notranslate"><span class="pre">m_probability_threshold</span></code> is the fusion probability threshold above
which WarpX reduces the fusion multiplier.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.fusion_probability_target_value</span></code> (<cite>float</cite>) optional.</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">nuclearfusion</span></code>.
When the probability of fusion for a given collision exceeds
<code class="docutils literal notranslate"><span class="pre">fusion_probability_threshold</span></code>, WarpX reduces the fusion multiplier for
that collisions such that the fusion probability approches <code class="docutils literal notranslate"><span class="pre">fusion_probability_target_value</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_density</span></code> (<cite>float</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code> and <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code>. The density of the background in <span class="math notranslate nohighlight">\(m^{-3}\)</span>.
Can also provide <code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_density(x,y,z,t)</span></code> using the parser
initialization style for spatially and temporally varying density. With <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code>, if a function
is used for the background density, the input parameter <code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.max_background_density</span></code>
must also be provided to calculate the maximum collision probability.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_temperature</span></code> (<cite>float</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code> and <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code>. The temperature of the background in Kelvin.
Can also provide <code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_temperature(x,y,z,t)</span></code> using the parser
initialization style for spatially and temporally varying temperature.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_mass</span></code> (<cite>float</cite>) optional</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code> and <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code>. The mass of the background gas in kg.
With <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code>, if not given the mass of the colliding species will be used unless ionization is
included in which case the mass of the product species will be used.
With <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code>, and <code class="docutils literal notranslate"><span class="pre">background_type</span></code> set to <code class="docutils literal notranslate"><span class="pre">electrons</span></code>, if not given defaults to the electron mass. With
<code class="docutils literal notranslate"><span class="pre">background_type</span></code> set to <code class="docutils literal notranslate"><span class="pre">ions</span></code>, the mass must be given.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_charge_state</span></code> (<cite>float</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code>, where it is required when <code class="docutils literal notranslate"><span class="pre">background_type</span></code> is set to <code class="docutils literal notranslate"><span class="pre">ions</span></code>.
This specifies the charge state of the background ions.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_type</span></code> (<cite>string</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_stopping</span></code>, where it is required, the type of the background.
The possible values are <code class="docutils literal notranslate"><span class="pre">electrons</span></code> and <code class="docutils literal notranslate"><span class="pre">ions</span></code>. When <code class="docutils literal notranslate"><span class="pre">electrons</span></code>, equation 14.12 from Goldston and Rutherford is used.
This formula is based on Coulomb collisions with the approximations that <span class="math notranslate nohighlight">\(M_b &gt;&gt; m_e\)</span> and <span class="math notranslate nohighlight">\(V &lt;&lt; v_{thermal\_e}\)</span>,
and the assumption that the electrons have a Maxwellian distribution with temperature <span class="math notranslate nohighlight">\(T_e\)</span>.</p>
<div class="math notranslate nohighlight">
\[\frac{dV}{dt} = - \frac{2^{1/2}n_eZ_b^2e^4m_e^{1/2}\log\Lambda}{12\pi^{3/2}\epsilon_0M_bT_e^{3/2}}V\]</div>
<p>where <span class="math notranslate nohighlight">\(V\)</span> is each velocity component, <span class="math notranslate nohighlight">\(n_e\)</span> is the background density, <span class="math notranslate nohighlight">\(Z_b\)</span> is the ion charge state,
<span class="math notranslate nohighlight">\(e\)</span> is the electron charge, <span class="math notranslate nohighlight">\(m_e\)</span> is the background mass, <span class="math notranslate nohighlight">\(\log\Lambda=\log((12\pi/Z_b)(n_e\lambda_{de}^3))\)</span>,
<span class="math notranslate nohighlight">\(\lambda_{de}\)</span> is the DeBye length, and <span class="math notranslate nohighlight">\(M_b\)</span> is the ion mass.
The equation is integrated over a time step, giving <span class="math notranslate nohighlight">\(V(t+dt) = V(t)*\exp(-\alpha*{dt})\)</span>
where <span class="math notranslate nohighlight">\(\alpha\)</span> is the factor multiplying <span class="math notranslate nohighlight">\(V\)</span>.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">ions</span></code>, equation 14.20 is used.
This formula is based on Coulomb collisions with the approximations that <span class="math notranslate nohighlight">\(M_b &gt;&gt; M\)</span> and <span class="math notranslate nohighlight">\(V &gt;&gt; v_{thermal\_i}\)</span>.
The background ion temperature only appears in the <span class="math notranslate nohighlight">\(\log\Lambda\)</span> term.</p>
<div class="math notranslate nohighlight">
\[\frac{dW_b}{dt} = - \frac{2^{1/2}n_iZ^2Z_b^2e^4M_b^{1/2}\log\Lambda}{8\pi\epsilon_0MW_b^{1/2}}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_b\)</span> is the ion energy, <span class="math notranslate nohighlight">\(n_i\)</span> is the background density,
<span class="math notranslate nohighlight">\(Z\)</span> is the charge state of the background ions, <span class="math notranslate nohighlight">\(Z_b\)</span> is the ion charge state,
<span class="math notranslate nohighlight">\(e\)</span> is the electron charge, <span class="math notranslate nohighlight">\(M_b\)</span> is the ion mass, <span class="math notranslate nohighlight">\(\log\Lambda=\log((12\pi/Z_b)(n_i\lambda_{di}^3))\)</span>,
<span class="math notranslate nohighlight">\(\lambda_{di}\)</span> is the DeBye length, and <span class="math notranslate nohighlight">\(M\)</span> is the background ion mass.
The equation is integrated over a time step, giving <span class="math notranslate nohighlight">\(W_b(t+dt) = ((W_b(t)^{3/2}) - 3/2\beta{dt})^{2/3}\)</span>
where <span class="math notranslate nohighlight">\(\beta\)</span> is the term on the r.h.s except <span class="math notranslate nohighlight">\(W_b\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.scattering_processes</span></code> (<cite>strings</cite> separated by spaces)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code>. The MCC scattering processes that should be
included. Available options are <code class="docutils literal notranslate"><span class="pre">elastic</span></code>, <code class="docutils literal notranslate"><span class="pre">back</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">charge_exchange</span></code>
for ions and <code class="docutils literal notranslate"><span class="pre">elastic</span></code>, <code class="docutils literal notranslate"><span class="pre">excitationX</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">ionization</span></code> for electrons.
The <code class="docutils literal notranslate"><span class="pre">elastic</span></code> option uses hard-sphere scattering, with a differential
cross section that is independent of angle.
With <code class="docutils literal notranslate"><span class="pre">charge_exchange</span></code>, the ion velocity is replaced with the neutral
velocity, chosen from a Maxwellian based on the value of
<code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.background_temperature</span></code>.
Multiple excitation events can be included for electrons corresponding to
excitation to different levels, the <code class="docutils literal notranslate"><span class="pre">X</span></code> above can be changed to a unique
identifier for each excitation process. For each scattering process specified
a path to a cross-section data file must  also be given. We use
<code class="docutils literal notranslate"><span class="pre">&lt;scattering_process&gt;</span></code> as a placeholder going forward.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.&lt;scattering_process&gt;_cross_section</span></code> (<cite>string</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code>. Path to the file containing cross-section data
for the given scattering processes. The cross-section file must have exactly
2 columns of data, the first containing equally spaced energies in eV and the
second the corresponding cross-section in <span class="math notranslate nohighlight">\(m^2\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.&lt;scattering_process&gt;_energy</span></code> (<cite>float</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code>. If the scattering process is either
<code class="docutils literal notranslate"><span class="pre">excitationX</span></code> or <code class="docutils literal notranslate"><span class="pre">ionization</span></code> the energy cost of that process must be given in eV.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;collision_name&gt;.ionization_species</span></code> (<cite>float</cite>)</dt><dd><p>Only for <code class="docutils literal notranslate"><span class="pre">background_mcc</span></code>. If the scattering process is <code class="docutils literal notranslate"><span class="pre">ionization</span></code> the
produced species must also be given. For example if argon properties is used
for the background gas, a species of argon ions should be specified here.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="numerics-and-algorithms">
<span id="running-cpp-parameters-numerics"></span><h2>Numerics and algorithms<a class="headerlink" href="#numerics-and-algorithms" title="Link to this heading"></a></h2>
<p>This section describes the input parameters used to select numerical methods and algorithms for your simulation setup.</p>
<section id="time-step">
<h3>Time step<a class="headerlink" href="#time-step" title="Link to this heading"></a></h3>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.cfl</span></code> (<cite>float</cite>) optional (default <cite>0.999</cite>)</dt><dd><p>The ratio between the actual timestep that is used in the simulation
and the Courant-Friedrichs-Lewy (CFL) limit. (e.g. for <cite>warpx.cfl=1</cite>,
the timestep will be exactly equal to the CFL limit.)
This parameter will only be used with the electromagnetic solver.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.const_dt</span></code> (<cite>float</cite>)</dt><dd><p>Allows direct specification of the time step size, in units of seconds.
When the electrostatic solver is being used, this must be supplied.
This can be used with the electromagnetic solver, overriding <code class="docutils literal notranslate"><span class="pre">warpx.cfl</span></code>, but
it is up to the user to ensure that the CFL condition is met.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="filtering">
<h3>Filtering<a class="headerlink" href="#filtering" title="Link to this heading"></a></h3>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.use_filter</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>1</cite>, except for RZ FDTD)</dt><dd><p>Whether to smooth the charge and currents on the mesh, after depositing them from the macro-particles.
This uses a bilinear filter (see the <a class="reference internal" href="../theory/picsar_theory.html#theory-pic-filter"><span class="std std-ref">filtering section</span></a>).
The default is <cite>1</cite> in all cases, except for simulations in RZ geometry using the FDTD solver.
With the RZ PSATD solver, the filtering is done in <span class="math notranslate nohighlight">\(k\)</span>-space.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Known bug: filter currently not working with FDTD solver in RZ geometry (see <a class="reference external" href="https://github.com/ECP-WarpX/WarpX/issues/1943">https://github.com/ECP-WarpX/WarpX/issues/1943</a>).</p>
</div>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.filter_npass_each_dir</span></code> (<cite>3 int</cite>) optional (default <cite>1 1 1</cite>)</dt><dd><p>Number of passes along each direction for the bilinear filter.
In 2D simulations, only the first two values are read.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.use_filter_compensation</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>0</cite>)</dt><dd><p>Whether to add compensation when applying filtering.
This is only supported with the RZ spectral solver.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="particle-push-charge-and-current-deposition-field-gathering">
<h3>Particle push, charge and current deposition, field gathering<a class="headerlink" href="#particle-push-charge-and-current-deposition-field-gathering" title="Link to this heading"></a></h3>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.current_deposition</span></code> (<cite>string</cite>, optional)</dt><dd><p>This parameter selects the algorithm for the deposition of the current density.
Available options are: <code class="docutils literal notranslate"><span class="pre">direct</span></code>, <code class="docutils literal notranslate"><span class="pre">esirkepov</span></code>, and <code class="docutils literal notranslate"><span class="pre">vay</span></code>. The default choice
is <code class="docutils literal notranslate"><span class="pre">esirkepov</span></code> for FDTD maxwell solvers and <code class="docutils literal notranslate"><span class="pre">direct</span></code> for standard or
Galilean PSATD solver (that is, with <code class="docutils literal notranslate"><span class="pre">algo.maxwell_solver</span> <span class="pre">=</span> <span class="pre">psatd</span></code>).
Note that <code class="docutils literal notranslate"><span class="pre">vay</span></code> is only available for <code class="docutils literal notranslate"><span class="pre">algo.maxwell_solver</span> <span class="pre">=</span> <span class="pre">psatd</span></code>.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">direct</span></code></p>
<p>The current density is deposited as described in the section <a class="reference internal" href="../theory/picsar_theory.html#current-deposition"><span class="std std-ref">Current deposition</span></a>.
This deposition scheme does not conserve charge.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">esirkepov</span></code></p>
<p>The current density is deposited as described in
<a class="reference external" href="https://www.sciencedirect.com/science/article/pii/S0010465500002289">(Esirkepov, CPC, 2001)</a>.
This deposition scheme guarantees charge conservation for shape factors of arbitrary order.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">vay</span></code></p>
<p>The current density is deposited as described in <a class="reference external" href="https://doi.org/10.1016/j.jcp.2013.03.010">(Vay et al, 2013)</a> (see section <a class="reference internal" href="../theory/picsar_theory.html#current-deposition"><span class="std std-ref">Current deposition</span></a> for more details).
This option guarantees charge conservation only when used in combination
with <code class="docutils literal notranslate"><span class="pre">psatd.periodic_single_box_fft=1</span></code>, that is, only for periodic single-box
simulations with global FFTs without guard cells. The implementation for domain
decomposition with local FFTs over guard cells is planned but not yet completed.</p>
</li>
</ol>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.charge_deposition</span></code> (<cite>string</cite>, optional)</dt><dd><p>The algorithm for the charge density deposition. Available options are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">standard</span></code>: standard charge deposition algorithm, described in
the <a class="reference internal" href="../theory/picsar_theory.html#theory-pic"><span class="std std-ref">particle-in-cell theory section</span></a>.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span></code> (<cite>string</cite>, optional)</dt><dd><p>The algorithm for field gathering. Available options are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">energy-conserving</span></code>: gathers directly from the grid points (either staggered
or nodal grid points depending on <code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">momentum-conserving</span></code>: first average the fields from the grid points to
the nodes, and then gather from the nodes.</p></li>
</ul>
</div></blockquote>
<p>Default: <code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span> <span class="pre">=</span> <span class="pre">energy-conserving</span></code> with collocated or staggered grids (note that <code class="docutils literal notranslate"><span class="pre">energy-conserving</span></code> and <code class="docutils literal notranslate"><span class="pre">momentum-conserving</span></code> are equivalent with collocated grids), <code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span> <span class="pre">=</span> <span class="pre">momentum-conserving</span></code> with hybrid grids.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.particle_pusher</span></code> (<cite>string</cite>, optional)</dt><dd><p>The algorithm for the particle pusher. Available options are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">boris</span></code>: Boris pusher.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">vay</span></code>: Vay pusher (see <a class="reference external" href="https://aip.scitation.org/doi/10.1063/1.2837054">Vay, Phys. Plasmas (2008)</a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">higuera</span></code>: Higuera-Cary pusher (see <a class="reference external" href="https://aip.scitation.org/doi/10.1063/1.4979989">Higuera and Cary, Phys. Plasmas (2017)</a>)</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">algo.particle_pusher</span></code> is not specified, <code class="docutils literal notranslate"><span class="pre">boris</span></code> is the default.</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.particle_shape</span></code> (<cite>integer</cite>; <cite>1</cite>, <cite>2</cite>, or <cite>3</cite>)</dt><dd><p>The order of the shape factors (splines) for the macro-particles along all spatial directions: <cite>1</cite> for linear, <cite>2</cite> for quadratic, <cite>3</cite> for cubic.
Low-order shape factors result in faster simulations, but may lead to more noisy results.
High-order shape factors are computationally more expensive, but may increase the overall accuracy of the results. For production runs it is generally safer to use high-order shape factors, such as cubic order.</p>
<p>Note that this input parameter is not optional and must always be set in all input files provided that there is at least one particle species (set in input as <code class="docutils literal notranslate"><span class="pre">particles.species_names</span></code>) or one laser species (set in input as <code class="docutils literal notranslate"><span class="pre">lasers.names</span></code>) in the simulation. No default value is provided automatically.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="maxwell-solver">
<h3>Maxwell solver<a class="headerlink" href="#maxwell-solver" title="Link to this heading"></a></h3>
<p>Two families of Maxwell solvers are implemented in WarpX, based on the Finite-Difference Time-Domain method (FDTD) or the Pseudo-Spectral Analytical Time-Domain method (PSATD), respectively.</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.maxwell_solver</span></code> (<cite>string</cite>, optional)</dt><dd><p>The algorithm for the Maxwell field solver.
Available options are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">yee</span></code>: Yee FDTD solver.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ckc</span></code>: (not available in <code class="docutils literal notranslate"><span class="pre">RZ</span></code> geometry) Cole-Karkkainen solver with Cowan
coefficients (see <a class="reference external" href="https://journals.aps.org/prab/abstract/10.1103/PhysRevSTAB.16.041303">Cowan, PRSTAB 16 (2013)</a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">psatd</span></code>: Pseudo-spectral solver (see <a class="reference internal" href="../theory/picsar_theory.html#theory-pic-mwsolve-psatd"><span class="std std-ref">theory</span></a>)</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ect</span></code>: Enlarged cell technique (conformal finite difference solver. See Xiao and Liu,</dt><dd><p>IEEE Antennas and Propagation Society International Symposium (2005),
&lt;<a class="reference external" href="https://ieeexplore.ieee.org/document/1551259">https://ieeexplore.ieee.org/document/1551259</a>&gt;)</p>
</dd>
</dl>
</li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">algo.maxwell_solver</span></code> is not specified, <code class="docutils literal notranslate"><span class="pre">yee</span></code> is the default.</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> (<cite>string</cite>, optional)</dt><dd><p>The medium for evaluating the Maxwell solver. Available options are :</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">vacuum</span></code>: vacuum properties are used in the Maxwell solver.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">macroscopic</span></code>: macroscopic Maxwell equation is evaluated. If this option is selected, then the corresponding properties of the medium must be provided using <code class="docutils literal notranslate"><span class="pre">macroscopic.sigma</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.epsilon</span></code>, and <code class="docutils literal notranslate"><span class="pre">macroscopic.mu</span></code> for each case where the initialization style is <code class="docutils literal notranslate"><span class="pre">constant</span></code>.  Otherwise if the initialization style uses the parser, <code class="docutils literal notranslate"><span class="pre">macroscopic.sigma_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.epsilon_function(x,y,z)</span></code> and/or <code class="docutils literal notranslate"><span class="pre">macroscopic.mu_function(x,y,z)</span></code> must be provided using the parser initialization style for spatially varying macroscopic properties.</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is not specified, <code class="docutils literal notranslate"><span class="pre">vacuum</span></code> is the default.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.yee_coupled_solver</span></code> (<cite>string</cite> optional)</dt><dd><p>If Maxwell is coupled with another solver.
Options are :</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">MaxwellLondon</span></code>: Couple London with Maxwell yee-scheme. If this option is selected, then</dt><dd><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">london.penetration_depth</span></code> must be specified and</dt><dd><p><code class="docutils literal notranslate"><span class="pre">london.superconductor_function(x,y,z)</span></code> must be provided to specify the superconducting region with an analytical function.</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: pure FDTD with yee-scheme</p></li>
</ul>
<p>If <code class="docutils literal notranslate"><span class="pre">algo.yee_coupled_solver</span></code> is not specified, <code class="docutils literal notranslate"><span class="pre">None</span></code> is the default</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.macroscopic_sigma_method</span></code> (<cite>string</cite>, optional)</dt><dd><p>The algorithm for updating electric field when <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is macroscopic. Available options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">backwardeuler</span></code> is a fully-implicit, first-order in time scheme for E-update (default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">laxwendroff</span></code> is the semi-implicit, second order in time scheme for E-update.</p></li>
</ul>
<p>Comparing the two methods, Lax-Wendroff is more prone to developing oscillations and requires a smaller timestep for stability. On the other hand, Backward Euler is more robust but it is first-order accurate in time compared to the second-order Lax-Wendroff method.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.sigma_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.epsilon_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.mu_function(x,y,z)</span></code> (<cite>string</cite>)</dt><dd><p>To initialize spatially varying conductivity, permittivity, and permeability, respectively,
using a mathematical function in the input. Constants required in the
mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>. These parameters are parsed
if <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium=macroscopic</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.sigma</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.epsilon</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.mu</span></code> (<cite>double</cite>)</dt><dd><p>To initialize a constant conductivity, permittivity, and permeability of the
computational medium, respectively. The default values are the corresponding values
in vacuum.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_Ms</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.gamma</span></code> (<cite>double</cite>)</dt><dd><p>To initialize a constant saturation magnetization, Gilbert damping constant, and gyromagnetic ratio of the
computational medium, respectively. The value of <code class="docutils literal notranslate"><span class="pre">macroscopic.gamma</span></code> for electron spins is -1.759e11 Coulomb/kg.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_Ms_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_alpha_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.gamma_function(x,y,z)</span></code> (<cite>string</cite>)</dt><dd><p>To initialize spatially varying saturation magnetization, Gilbert damping constant, and gyromagnetic ratio, respectively,
using a mathematical function in the input. Constants required in the
mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>. These parameters are parsed
if <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium=macroscopic</span></code>.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_normalized_error</span></code> (<cite>double</cite>; default: <cite>0.1</cite>)</dt><dd><p>The maximum relative amount we let M deviate from Ms before aborting for the LLG equation for saturated cases, i.e., <cite>mag_M_normalization&gt;0</cite>.
For the unsaturated case, i.e., <cite>mag_M_normalization=0</cite>, this is the maximum relative amount we let M overshoot Ms and renormalize to Ms before aborting.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_max_iter</span></code> (<cite>int</cite>; default: <cite>100</cite>)</dt><dd><p>The maximum number of iterations allowed of the 2nd-order trapezoidal scheme for the LLG equation. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_tol</span></code> (<cite>double</cite>; default: <cite>0.0001</cite>)</dt><dd><p>The relative tolerance stopping criteria for 2nd-order iterative algorithm of the 2nd-order trapezoidal scheme for the LLG equation. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_LLG_anisotropy_axis</span></code> (default: <code class="docutils literal notranslate"><span class="pre">0.0</span></code> in all directions)</dt><dd><p>The anisotropy axis of the term H_anisotropy in H_eff for the LLG updates. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mag_time_scheme_order</span></code> (<cite>1</cite> or <cite>2</cite>; default: <cite>1</cite>)</dt><dd><p>The value of the time advancement scheme of M field. <cite>mag_time_scheme_order==1</cite> is the 1st-order Eulerian scheme and <cite>mag_time_scheme_order==2</cite> is the 2nd-order trapezoidal scheme for the LLG equation. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mag_M_normalization</span></code> (<cite>0</cite> or <cite>1</cite> or <cite>2</cite>; no default, must be user-input)</dt><dd><p>The strategy of normalizating M magnitude. <cite>mag_M_normalization==0</cite> indicates unsaturated materials, i.e. <cite>M_magnitude</cite> is no larger than the saturation magnetization <cite>mag_Ms</cite>.
Therefore, no normalization of M magnitude is applied. <cite>mag_M_normalization&gt;0</cite> indicates saturated materials, i.e. <cite>M_magnitude</cite> is equal the saturation magnetization <cite>mag_Ms</cite>.
In this case, the value of <cite>mag_M_normalization</cite> indicates when to apply normalization in the second-order magnetization scheme. <cite>mag_M_normalization==1</cite> applies it after each iteration; <cite>mag_M_normalization==2</cite> applies it after the iterations have converged.
In the first-order magnetization scheme, <cite>mag_M_normalization==1</cite> is equivalent to <cite>mag_M_normalization==2</cite>, and both normalize <cite>M_magnitude</cite> by <cite>mag_Ms</cite>.
This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mag_LLG_coupling</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>1</cite>)</dt><dd><p>Turn on coupling of Maxwell solution to the LLG updates. <cite>mag_LLG_coupling==1</cite> enables, <cite>mag_LLG_coupling=0</cite> diables. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mag_LLG_exchange_coupling</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>0</cite>)</dt><dd><p>Turn on the exchange coupling term H_exchange in H_eff for the LLG updates. <cite>mag_LLG_exchange_coupling=1</cite> enables, <cite>mag_LLG_exchange_coupling=0</cite> diables. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mag_LLG_anisotropy_coupling</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>0</cite>)</dt><dd><p>Turn on the anisotropy coupling term H_anisotropy in H_eff for the LLG updates. <cite>mag_LLG_anisotropy_coupling=1</cite> enables, <cite>mag_LLG_anisotropy_coupling=0</cite> diables. This requires <cite>USE_LLG=TRUE</cite> in the GNUMakefile.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">interpolation.galerkin_scheme</span></code> (<cite>0</cite> or <cite>1</cite>)</dt><dd><p>Whether to use a Galerkin scheme when gathering fields to particles.
When set to <cite>1</cite>, the interpolation orders used for field-gathering are reduced for certain field components along certain directions.
For example, <span class="math notranslate nohighlight">\(E_z\)</span> is gathered using <code class="docutils literal notranslate"><span class="pre">algo.particle_shape</span></code> along <span class="math notranslate nohighlight">\((x,y)\)</span> and <code class="docutils literal notranslate"><span class="pre">algo.particle_shape</span> <span class="pre">-</span> <span class="pre">1</span></code> along <span class="math notranslate nohighlight">\(z\)</span>.
See equations (21)-(23) of (<a class="reference external" href="https://doi.org/10.1016/j.jcp.2013.04.006">Godfrey and Vay, 2013</a>) and associated references for details.
Defaults to <cite>1</cite> unless <code class="docutils literal notranslate"><span class="pre">warpx.do_nodal</span> <span class="pre">=</span> <span class="pre">1</span></code> and/or <code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span> <span class="pre">=</span> <span class="pre">momentum-conserving</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default behavior should not normally be changed.
At present, this parameter is intended mainly for testing and development purposes.</p>
</div>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">interpolation.field_centering_nox</span></code>, <code class="docutils literal notranslate"><span class="pre">interpolation.field_centering_noy</span></code>, <code class="docutils literal notranslate"><span class="pre">interpolation.field_centering_noz</span></code> (default: <code class="docutils literal notranslate"><span class="pre">2</span></code> in all directions)</dt><dd><p>The order of interpolation used with staggered grids (<code class="docutils literal notranslate"><span class="pre">warpx.do_nodal</span> <span class="pre">=</span> <span class="pre">0</span></code>) and momentum-conserving field gathering (<code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span> <span class="pre">=</span> <span class="pre">momentum-conserving</span></code>) to interpolate the electric and magnetic fields from the cell centers to the cell nodes, before gathering the fields from the cell nodes to the particle positions. High-order interpolation (order 8 in each direction, at least) is necessary to ensure stability in typical LWFA boosted-frame simulations using the Galilean PSATD or comoving PSATD schemes. This finite-order interpolation is used only when the PSATD solver is used for Maxwell’s equations. With the FDTD solver, basic linear interpolation is used instead.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">interpolation.current_centering_nox</span></code>, <code class="docutils literal notranslate"><span class="pre">interpolation.current_centering_noy</span></code>, <code class="docutils literal notranslate"><span class="pre">interpolation.current_centering_noz</span></code> (default: <code class="docutils literal notranslate"><span class="pre">2</span></code> in all directions)</dt><dd><p>The order of interpolation used to center the currents from nodal to staggered grids (if <code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span> <span class="pre">=</span> <span class="pre">1</span></code>), before pushing the Maxwell fields on staggered grids. This finite-order interpolation is used only when the PSATD solver is used for Maxwell’s equations. With the FDTD solver, basic linear interpolation is used instead.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span></code> (<cite>0</cite> or <cite>1</cite> ; default: 0)</dt><dd><p>If true, the current is deposited on a nodal grid and then centered to a staggered grid (Yee grid), using finite-order interpolation. If <code class="docutils literal notranslate"><span class="pre">warpx.do_nodal</span> <span class="pre">=</span> <span class="pre">1</span></code>, the Maxwell fields are pushed on a nodal grid, it is not necessary to center the currents to a staggered grid, and we set therefore <code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span> <span class="pre">=</span> <span class="pre">0</span></code> automatically, overwriting the user-defined input.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_dive_cleaning</span></code> (<cite>0</cite> or <cite>1</cite> ; default: 0)</dt><dd><p>Whether to use modified Maxwell equations that progressively eliminate
the error in <span class="math notranslate nohighlight">\(div(E)-\rho\)</span>. This can be useful when using a current
deposition algorithm which is not strictly charge-conserving, or when
using mesh refinement. These modified Maxwell equation will cause the error
to propagate (at the speed of light) to the boundaries of the simulation
domain, where it can be absorbed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_nodal</span></code> (<cite>0</cite> or <cite>1</cite> ; default: 0)</dt><dd><p>Whether to use a nodal grid (i.e. all fields are defined at the
same points in space) or a staggered grid (i.e. Yee grid ; different
fields are defined at different points in space)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_subcycling</span></code> (<cite>0</cite> or <cite>1</cite>; default: 0)</dt><dd><p>Whether or not to use sub-cycling. Different refinement levels have a
different cell size, which results in different Courant–Friedrichs–Lewy
(CFL) limits for the time step. By default, when using mesh refinement,
the same time step is used for all levels. This time step is
taken as the CFL limit of the finest level. Hence, for coarser
levels, the timestep is only a fraction of the CFL limit for this
level, which may lead to numerical artifacts. With sub-cycling, each level
evolves with its own time step, set to its own CFL limit. In practice, it
means that when level 0 performs one iteration, level 1 performs two
iterations. Currently, this option is only supported when
<code class="docutils literal notranslate"><span class="pre">amr.max_level</span> <span class="pre">=</span> <span class="pre">1</span></code>. More information can be found at
<a class="reference external" href="https://ieeexplore.ieee.org/document/8659392">https://ieeexplore.ieee.org/document/8659392</a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>0</cite>)</dt><dd><p>Whether to use the multi-J algorithm, where current deposition and field update are performed multiple times within each time step. The number of sub-steps is determined by the input parameter <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J_n_depositions</span></code>. Unlike sub-cycling, field gathering is performed only once per time step, as in regular PIC cycles. When <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span> <span class="pre">=</span> <span class="pre">1</span></code>, we perform linear interpolation of two distinct currents deposited at the beginning and the end of the time step, instead of using one single current deposited at half time. For simulations with strong numerical Cherenkov instability (NCI), it is recommended to use the multi-J algorithm in combination with <code class="docutils literal notranslate"><span class="pre">psatd.do_time_averaging</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J_n_depositions</span></code> (integer)</dt><dd><p>Number of sub-steps to use with the multi-J algorithm, when <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span> <span class="pre">=</span> <span class="pre">1</span></code>.
Note that this input parameter is not optional and must always be set in all input files where <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span> <span class="pre">=</span> <span class="pre">1</span></code>. No default value is provided automatically.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="maxwell-solver-psatd-method">
<h3>Maxwell solver: PSATD method<a class="headerlink" href="#maxwell-solver-psatd-method" title="Link to this heading"></a></h3>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.nox</span></code>, <code class="docutils literal notranslate"><span class="pre">psatd.noy</span></code>, <code class="docutils literal notranslate"><span class="pre">pstad.noz</span></code> (<cite>integer</cite>) optional (default <cite>16</cite> for all)</dt><dd><p>The order of accuracy of the spatial derivatives, when using the code compiled with a PSATD solver.
If <code class="docutils literal notranslate"><span class="pre">psatd.periodic_single_box_fft</span></code> is used, these can be set to <code class="docutils literal notranslate"><span class="pre">inf</span></code> for infinite-order PSATD.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.nx_guard</span></code>, <code class="docutils literal notranslate"><span class="pre">psatd.ny_guard</span></code>, <code class="docutils literal notranslate"><span class="pre">psatd.nz_guard</span></code> (<cite>integer</cite>) optional</dt><dd><p>The number of guard cells to use with PSATD solver.
If not set by users, these values are calculated automatically and determined <em>empirically</em> and
equal the order of the solver for collocated grids and half the order of the solver for staggered grids.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.periodic_single_box_fft</span></code> (<cite>0</cite> or <cite>1</cite>; default: 0)</dt><dd><p>If true, this will <em>not</em> incorporate the guard cells into the box over which FFTs are performed.
This is only valid when WarpX is run with periodic boundaries and a single box.
In this case, using <cite>psatd.periodic_single_box_fft</cite> is equivalent to using a global FFT over the whole domain.
Therefore, all the approximations that are usually made when using local FFTs with guard cells
(for problems with multiple boxes) become exact in the case of the periodic, single-box FFT without guard cells.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">psatd.current_correction</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>1</cite>, with the exceptions mentioned below)</dt><dd><p>If true, a current correction scheme in Fourier space is applied in order to guarantee charge conservation.
The default value is <code class="docutils literal notranslate"><span class="pre">psatd.current_correction=1</span></code>, unless a charge-conserving current deposition scheme is used (by setting <code class="docutils literal notranslate"><span class="pre">algo.current_deposition=esirkepov</span></code> or <code class="docutils literal notranslate"><span class="pre">algo.current_deposition=vay</span></code>) or unless the <code class="docutils literal notranslate"><span class="pre">div(E)</span></code> cleaning scheme is used (by setting <code class="docutils literal notranslate"><span class="pre">warpx.do_dive_cleaning=1</span></code>).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">psatd.v_galilean</span></code> is zero, the spectral solver used is the standard PSATD scheme described in (<a class="reference external" href="https://doi.org/10.1016/j.jcp.2013.03.010">Vay et al, JCP 243, 2013</a>) and the current correction reads</p>
<div class="math notranslate nohighlight">
\[\widehat{\boldsymbol{J}}^{\,n+1/2}_{\mathrm{correct}} = \widehat{\boldsymbol{J}}^{\,n+1/2}
- \bigg(\boldsymbol{k}\cdot\widehat{\boldsymbol{J}}^{\,n+1/2}
- i \frac{\widehat{\rho}^{n+1} - \widehat{\rho}^{n}}{\Delta{t}}\bigg) \frac{\boldsymbol{k}}{k^2}\]</div>
<p>If <code class="docutils literal notranslate"><span class="pre">psatd.v_galilean</span></code> is non-zero, the spectral solver used is the Galilean PSATD scheme described in (<a class="reference external" href="https://doi.org/10.1103/PhysRevE.94.053305">Lehe et al, PRE 94, 2016</a>) and the current correction reads</p>
<div class="math notranslate nohighlight">
\[\widehat{\boldsymbol{J}}^{\,n+1/2}_{\mathrm{correct}} = \widehat{\boldsymbol{J}}^{\,n+1/2}
- \bigg(\boldsymbol{k}\cdot\widehat{\boldsymbol{J}}^{\,n+1/2} - (\boldsymbol{k}\cdot\boldsymbol{v}_G)
\,\frac{\widehat\rho^{n+1} - \widehat\rho^{n}\theta^2}{1 - \theta^2}\bigg) \frac{\boldsymbol{k}}{k^2}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta=\exp(i\,\boldsymbol{k}\cdot\boldsymbol{v}_G\,\Delta{t}/2)\)</span>.</p>
<p>This option is currently implemented only for the standard PSATD, Galilean PSATD, and averaged Galilean PSATD schemes, while it is not yet available for the multi-J algorithm.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho</span></code> (<cite>0</cite> or <cite>1</cite>)</dt><dd><p>If true, the update equation for the electric field is expressed in terms of both the current density and the charge density, namely <span class="math notranslate nohighlight">\(\widehat{\boldsymbol{J}}^{\,n+1/2}\)</span>, <span class="math notranslate nohighlight">\(\widehat\rho^{n}\)</span>, and <span class="math notranslate nohighlight">\(\widehat\rho^{n+1}\)</span>.
If false, instead, the update equation for the electric field is expressed in terms of the current density <span class="math notranslate nohighlight">\(\widehat{\boldsymbol{J}}^{\,n+1/2}\)</span> only.
If charge is expected to be conserved (by setting, for example, <code class="docutils literal notranslate"><span class="pre">psatd.current_correction=1</span></code>), then the two formulations are expected to be equivalent.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">psatd.v_galilean</span></code> is zero, the spectral solver used is the standard PSATD scheme described in (<a class="reference external" href="https://doi.org/10.1016/j.jcp.2013.03.010">Vay et al, JCP 243, 2013</a>):</p>
<ol class="arabic simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho=0</span></code>, the update equation for the electric field reads</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\widehat{\boldsymbol{E}}^{\,n+1}= &amp; \:
C \widehat{\boldsymbol{E}}^{\,n} + i \, \frac{S c}{k} \boldsymbol{k}\times\widehat{\boldsymbol{B}}^{\,n}
- \frac{S}{\epsilon_0 c \, k} \widehat{\boldsymbol{J}}^{\,n+1/2} \\[0.2cm]
&amp; +\frac{1-C}{k^2} (\boldsymbol{k}\cdot\widehat{\boldsymbol{E}}^{\,n}) \boldsymbol{k}
+ \frac{1}{\epsilon_0 k^2} \left(\frac{S}{c \, k}-\Delta{t}\right)
(\boldsymbol{k}\cdot\widehat{\boldsymbol{J}}^{\,n+1/2}) \boldsymbol{k}
\end{split}\end{split}\]</div>
<ol class="arabic simple" start="2">
<li><p>if <code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho=1</span></code>, the update equation for the electric field reads</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\widehat{\boldsymbol{E}}^{\,n+1}= &amp; \:
C\widehat{\boldsymbol{E}}^{\,n} + i \, \frac{S c}{k} \boldsymbol{k}\times\widehat{\boldsymbol{B}}^{\,n}
- \frac{S}{\epsilon_0 c \, k} \widehat{\boldsymbol{J}}^{\,n+1/2} \\[0.2cm]
&amp; + \frac{i}{\epsilon_0 k^2} \left(C-\frac{S}{c\,k}\frac{1}{\Delta{t}}\right)
\widehat{\rho}^{n} \boldsymbol{k} - \frac{i}{\epsilon_0 k^2} \left(1-\frac{S}{c \, k}
\frac{1}{\Delta{t}}\right)\widehat{\rho}^{n+1} \boldsymbol{k}
\end{split}\end{split}\]</div>
<p>The coefficients <span class="math notranslate nohighlight">\(C\)</span> and <span class="math notranslate nohighlight">\(S\)</span> are defined in (<a class="reference external" href="https://doi.org/10.1016/j.jcp.2013.03.010">Vay et al, JCP 243, 2013</a>).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">psatd.v_galilean</span></code> is non-zero, the spectral solver used is the Galilean PSATD scheme described in (<a class="reference external" href="https://doi.org/10.1103/PhysRevE.94.053305">Lehe et al, PRE 94, 2016</a>):</p>
<ol class="arabic simple">
<li><p>if <code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho=0</span></code>, the update equation for the electric field reads</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\widehat{\boldsymbol{E}}^{\,n+1} = &amp; \:
\theta^{2} C \widehat{\boldsymbol{E}}^{\,n} + i \, \theta^{2} \frac{S c}{k}
\boldsymbol{k}\times\widehat{\boldsymbol{B}}^{\,n}
+ \frac{i \, \nu \, \theta \, \chi_1 - \theta^{2} S}{\epsilon_0 c \, k}
\widehat{\boldsymbol{J}}^{\,n+1/2} \\[0.2cm]
&amp; + \theta^{2} \frac{\chi_2-\chi_3}{k^{2}}
(\boldsymbol{k}\cdot\widehat{\boldsymbol{E}}^{\,n}) \boldsymbol{k}
+ i \, \frac{\chi_2\left(\theta^{2}-1\right)}{\epsilon_0 c \, k^{3} \nu}
(\boldsymbol{k}\cdot\widehat{\boldsymbol{J}}^{\,n+1/2}) \boldsymbol{k}
\end{split}\end{split}\]</div>
<ol class="arabic simple" start="2">
<li><p>if <code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho=1</span></code>, the update equation for the electric field reads</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{split}
\widehat{\boldsymbol{E}}^{\,n+1} = &amp; \:
\theta^{2} C \widehat{\boldsymbol{E}}^{\,n} + i \, \theta^{2} \frac{S c}{k}
\boldsymbol{k}\times\widehat{\boldsymbol{B}}^{\,n}
+ \frac{i \, \nu \, \theta \, \chi_1 - \theta^{2} S}{\epsilon_0 c \, k}
\widehat{\boldsymbol{J}}^{\,n+1/2} \\[0.2cm]
&amp; + i \, \frac{\theta^{2} \chi_3}{\epsilon_0 k^{2}} \widehat{\rho}^{\,n} \boldsymbol{k}
- i \, \frac{\chi_2}{\epsilon_0 k^{2}} \widehat{\rho}^{\,n+1} \boldsymbol{k}
\end{split}\end{split}\]</div>
<p>The coefficients <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(S\)</span>, <span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(\nu\)</span>, <span class="math notranslate nohighlight">\(\chi_1\)</span>, <span class="math notranslate nohighlight">\(\chi_2\)</span>, and <span class="math notranslate nohighlight">\(\chi_3\)</span> are defined in (<a class="reference external" href="https://doi.org/10.1103/PhysRevE.94.053305">Lehe et al, PRE 94, 2016</a>).</p>
<p>The default value for <code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho</span></code> is <code class="docutils literal notranslate"><span class="pre">1</span></code> if <code class="docutils literal notranslate"><span class="pre">psatd.v_galilean</span></code> is non-zero and <code class="docutils literal notranslate"><span class="pre">0</span></code> otherwise.
The option <code class="docutils literal notranslate"><span class="pre">psatd.update_with_rho=0</span></code> is not implemented with the following algorithms:
comoving PSATD (<code class="docutils literal notranslate"><span class="pre">psatd.v_comoving</span></code>), time averaging (<code class="docutils literal notranslate"><span class="pre">psatd.do_time_averaging=1</span></code>), div(E) cleaning (<code class="docutils literal notranslate"><span class="pre">warpx.do_dive_cleaning=1</span></code>), and multi-J (<code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J=1</span></code>).</p>
<p>Note that the update with and without rho is also supported in RZ geometry.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.J_in_time</span></code> (<code class="docutils literal notranslate"><span class="pre">constant</span></code> or <code class="docutils literal notranslate"><span class="pre">linear</span></code>; default <code class="docutils literal notranslate"><span class="pre">constant</span></code>)</dt><dd><p>This determines whether the current density is assumed to be constant or linear in time, within the time step over which the electromagnetic fields are evolved.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.rho_in_time</span></code> (<code class="docutils literal notranslate"><span class="pre">linear</span></code>; default <code class="docutils literal notranslate"><span class="pre">linear</span></code>)</dt><dd><p>This determines whether the charge density is assumed to be linear in time, within the time step over which the electromagnetic fields are evolved.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.v_galilean</span></code> (<cite>3 floats</cite>, in units of the speed of light; default <code class="docutils literal notranslate"><span class="pre">0.</span> <span class="pre">0.</span> <span class="pre">0.</span></code>)</dt><dd><p>Defines the Galilean velocity.
A non-zero velocity activates the Galilean algorithm, which suppresses numerical Cherenkov instabilities (NCI) in boosted-frame simulations (see the section <a class="reference internal" href="../theory/boosted_frame.html#theory-boostedframe-galilean"><span class="std std-ref">Numerical Stability and alternate formulation in a Galilean frame</span></a> for more information).
This requires the code to be compiled with the spectral solver.
It also requires the use of the direct current deposition algorithm (by setting <code class="docutils literal notranslate"><span class="pre">algo.current_deposition</span> <span class="pre">=</span> <span class="pre">direct</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.use_default_v_galilean</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>0</cite>)</dt><dd><p>This can be used in boosted-frame simulations only and sets the Galilean velocity along the <span class="math notranslate nohighlight">\(z\)</span> direction automatically as <span class="math notranslate nohighlight">\(v_{G} = -\sqrt{1-1/\gamma^2}\)</span>, where <span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor of the boosted frame (set by <code class="docutils literal notranslate"><span class="pre">warpx.gamma_boost</span></code>).
See the section <a class="reference internal" href="../theory/boosted_frame.html#theory-boostedframe-galilean"><span class="std std-ref">Numerical Stability and alternate formulation in a Galilean frame</span></a> for more information on the Galilean algorithm for boosted-frame simulations.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.v_comoving</span></code> (3 floating-point values, in units of the speed of light; default <code class="docutils literal notranslate"><span class="pre">0.</span> <span class="pre">0.</span> <span class="pre">0.</span></code>)</dt><dd><p>Defines the comoving velocity in the comoving PSATD scheme.
A non-zero comoving velocity selects the comoving PSATD algorithm, which suppresses the numerical Cherenkov instability (NCI) in boosted-frame simulations, under certain assumptions. This option requires that WarpX is compiled with <code class="docutils literal notranslate"><span class="pre">USE_PSATD</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>. It also requires the use of direct current deposition (<code class="docutils literal notranslate"><span class="pre">algo.current_deposition</span> <span class="pre">=</span> <span class="pre">direct</span></code>) and has not been neither implemented nor tested with other current deposition schemes.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">psatd.do_time_averaging</span></code> (<cite>0</cite> or <cite>1</cite>; default: 0)</dt><dd><p>Whether to use an averaged Galilean PSATD algorithm or standard Galilean PSATD.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span></code> (<cite>0</cite> or <cite>1</cite>; default: <cite>0</cite>)</dt><dd><p>Whether to use the multi-J algorithm, where current deposition and field update are performed multiple times within each time step. The number of sub-steps is determined by the input parameter <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J_n_depositions</span></code>. Unlike sub-cycling, field gathering is performed only once per time step, as in regular PIC cycles. When <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span> <span class="pre">=</span> <span class="pre">1</span></code>, we perform linear interpolation of two distinct currents deposited at the beginning and the end of the time step, instead of using one single current deposited at half time. For simulations with strong numerical Cherenkov instability (NCI), it is recommended to use the multi-J algorithm in combination with <code class="docutils literal notranslate"><span class="pre">psatd.do_time_averaging</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J_n_depositions</span></code> (integer)</dt><dd><p>Number of sub-steps to use with the multi-J algorithm, when <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span> <span class="pre">=</span> <span class="pre">1</span></code>.
Note that this input parameter is not optional and must always be set in all input files where <code class="docutils literal notranslate"><span class="pre">warpx.do_multi_J</span> <span class="pre">=</span> <span class="pre">1</span></code>. No default value is provided automatically.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="maxwell-solver-macroscopic-media">
<h3>Maxwell solver: macroscopic media<a class="headerlink" href="#maxwell-solver-macroscopic-media" title="Link to this heading"></a></h3>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">algo.macroscopic_sigma_method</span></code> (<cite>string</cite>, optional)</dt><dd><p>The algorithm for updating electric field when <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is macroscopic. Available options are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">backwardeuler</span></code> is a fully-implicit, first-order in time scheme for E-update (default).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">laxwendroff</span></code> is the semi-implicit, second order in time scheme for E-update.</p></li>
</ul>
<p>Comparing the two methods, Lax-Wendroff is more prone to developing oscillations and requires a smaller timestep for stability. On the other hand, Backward Euler is more robust but it is first-order accurate in time compared to the second-order Lax-Wendroff method.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.sigma_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.epsilon_function(x,y,z)</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.mu_function(x,y,z)</span></code> (<cite>string</cite>)</dt><dd><p>To initialize spatially varying conductivity, permittivity, and permeability, respectively,
using a mathematical function in the input. Constants required in the
mathematical expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>. These parameters are parsed
if <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium=macroscopic</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.sigma</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.epsilon</span></code>, <code class="docutils literal notranslate"><span class="pre">macroscopic.mu</span></code> (<cite>double</cite>)</dt><dd><p>To initialize a constant conductivity, permittivity, and permeability of the
computational medium, respectively. The default values are the corresponding values
in vacuum.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="grid-types-collocated-staggered-hybrid">
<h3>Grid types (collocated, staggered, hybrid)<a class="headerlink" href="#grid-types-collocated-staggered-hybrid" title="Link to this heading"></a></h3>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span></code> (<cite>string</cite>, <code class="docutils literal notranslate"><span class="pre">collocated</span></code>, <code class="docutils literal notranslate"><span class="pre">staggered</span></code> or <code class="docutils literal notranslate"><span class="pre">hybrid</span></code>)</dt><dd><p>Whether to use a collocated grid (all fields defined at the cell nodes),
a staggered grid (fields defined on a Yee grid), or a hybrid grid (fields
and currents are interpolated back and forth between a staggered grid and a
nodal grid, must be used with momentum-conserving field gathering algorithm,
<code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span> <span class="pre">=</span> <span class="pre">momentum-conserving</span></code>).</p>
<p>Default: <code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span> <span class="pre">=</span> <span class="pre">staggered</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">interpolation.galerkin_scheme</span></code> (<cite>0</cite> or <cite>1</cite>)</dt><dd><p>Whether to use a Galerkin scheme when gathering fields to particles.
When set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, the interpolation orders used for field-gathering are reduced for certain field components along certain directions.
For example, <span class="math notranslate nohighlight">\(E_z\)</span> is gathered using <code class="docutils literal notranslate"><span class="pre">algo.particle_shape</span></code> along <span class="math notranslate nohighlight">\((x,y)\)</span> and <code class="docutils literal notranslate"><span class="pre">algo.particle_shape</span> <span class="pre">-</span> <span class="pre">1</span></code> along <span class="math notranslate nohighlight">\(z\)</span>.
See equations (21)-(23) of (<a class="reference external" href="https://doi.org/10.1016/j.jcp.2013.04.006">Godfrey and Vay, 2013</a>) and associated references for details.</p>
<p>Default: <code class="docutils literal notranslate"><span class="pre">interpolation.galerkin_scheme</span> <span class="pre">=</span> <span class="pre">0</span></code> with collocated grids and/or momentum-conserving field gathering, <code class="docutils literal notranslate"><span class="pre">interpolation.galerkin_scheme</span> <span class="pre">=</span> <span class="pre">1</span></code> otherwise.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The default behavior should not normally be changed.
At present, this parameter is intended mainly for testing and development purposes.</p>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.field_centering_nox</span></code>, <code class="docutils literal notranslate"><span class="pre">warpx.field_centering_noy</span></code>, <code class="docutils literal notranslate"><span class="pre">warpx.field_centering_noz</span></code> (<cite>integer</cite>, optional)</dt><dd><p>The order of interpolation used with staggered or hybrid grids (<code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span> <span class="pre">=</span> <span class="pre">staggered</span></code> or <code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span> <span class="pre">=</span> <span class="pre">hybrid</span></code>) and momentum-conserving field gathering (<code class="docutils literal notranslate"><span class="pre">algo.field_gathering</span> <span class="pre">=</span> <span class="pre">momentum-conserving</span></code>) to interpolate the electric and magnetic fields from the cell centers to the cell nodes, before gathering the fields from the cell nodes to the particle positions.</p>
<p>Default: <code class="docutils literal notranslate"><span class="pre">warpx.field_centering_no&lt;x,y,z&gt;</span> <span class="pre">=</span> <span class="pre">2</span></code> with staggered grids, <code class="docutils literal notranslate"><span class="pre">warpx.field_centering_no&lt;x,y,z&gt;</span> <span class="pre">=</span> <span class="pre">8</span></code> with hybrid grids (typically necessary to ensure stability in boosted-frame simulations of relativistic plasmas and beams).</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.current_centering_nox</span></code>, <code class="docutils literal notranslate"><span class="pre">warpx.current_centering_noy</span></code>, <code class="docutils literal notranslate"><span class="pre">warpx.current_centering_noz</span></code> (<cite>integer</cite>, optional)</dt><dd><p>The order of interpolation used with hybrid grids (<code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span> <span class="pre">=</span> <span class="pre">hybrid</span></code>) to interpolate the currents from the cell nodes to the cell centers when <code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span> <span class="pre">=</span> <span class="pre">1</span></code>, before pushing the Maxwell fields on staggered grids.</p>
<p>Default: <code class="docutils literal notranslate"><span class="pre">warpx.current_centering_no&lt;x,y,z&gt;</span> <span class="pre">=</span> <span class="pre">8</span></code> with hybrid grids (typically necessary to ensure stability in boosted-frame simulations of relativistic plasmas and beams).</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span></code> (<cite>bool</cite>, <cite>0</cite> or <cite>1</cite>)</dt><dd><p>If true, the current is deposited on a nodal grid and then centered to a staggered grid (Yee grid), using finite-order interpolation.</p>
<p>Default: <code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span> <span class="pre">=</span> <span class="pre">0</span></code> with collocated or staggered grids, <code class="docutils literal notranslate"><span class="pre">warpx.do_current_centering</span> <span class="pre">=</span> <span class="pre">1</span></code> with hybrid grids.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="additional-parameters">
<h3>Additional parameters<a class="headerlink" href="#additional-parameters" title="Link to this heading"></a></h3>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_dive_cleaning</span></code> (<cite>0</cite> or <cite>1</cite> ; default: 0)</dt><dd><p>Whether to use modified Maxwell equations that progressively eliminate
the error in <span class="math notranslate nohighlight">\(div(E)-\rho\)</span>. This can be useful when using a current
deposition algorithm which is not strictly charge-conserving, or when
using mesh refinement. These modified Maxwell equation will cause the error
to propagate (at the speed of light) to the boundaries of the simulation
domain, where it can be absorbed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_subcycling</span></code> (<cite>0</cite> or <cite>1</cite>; default: 0)</dt><dd><p>Whether or not to use sub-cycling. Different refinement levels have a
different cell size, which results in different Courant–Friedrichs–Lewy
(CFL) limits for the time step. By default, when using mesh refinement,
the same time step is used for all levels. This time step is
taken as the CFL limit of the finest level. Hence, for coarser
levels, the timestep is only a fraction of the CFL limit for this
level, which may lead to numerical artifacts. With sub-cycling, each level
evolves with its own time step, set to its own CFL limit. In practice, it
means that when level 0 performs one iteration, level 1 performs two
iterations. Currently, this option is only supported when
<code class="docutils literal notranslate"><span class="pre">amr.max_level</span> <span class="pre">=</span> <span class="pre">1</span></code>. More information can be found at
<a class="reference external" href="https://ieeexplore.ieee.org/document/8659392">https://ieeexplore.ieee.org/document/8659392</a>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.override_sync_intervals</span></code> (<cite>string</cite>) optional (default <cite>1</cite>)</dt><dd><p>Using the <a class="reference internal" href="#intervals-parser">Intervals parser</a> syntax, this string defines the timesteps at which
synchronization of sources (<cite>rho</cite> and <cite>J</cite>) and fields (<cite>E</cite> and <cite>B</cite>) on grid nodes at box
boundaries is performed. Since the grid nodes at the interface between two neighbor boxes are
duplicated in both boxes, an instability can occur if they have too different values.
This option makes sure that they are synchronized periodically.
Note that if Perfectly Matched Layers (PML) are used, synchronization of the <cite>E</cite> and <cite>B</cite> fields
is performed at every timestep regardless of this parameter.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.use_hybrid_QED</span></code> (<cite>bool</cite>; default: 0)</dt><dd><p>Will use the Hybird QED Maxwell solver when pushing fields: a QED correction is added to the
field solver to solve non-linear Maxwell’s equations, according to [Quantum Electrodynamics
vacuum polarization solver, P. Carneiro et al., <a class="reference external" href="https://arxiv.org/abs/1607.04224">ArXiv 2016</a>].
Note that this option can only be used with the PSATD build. Furthermore, one must set
<code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span> <span class="pre">=</span> <span class="pre">collocated</span></code> (which otherwise would be <code class="docutils literal notranslate"><span class="pre">staggered</span></code> by default).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.quantum_xi</span></code> (<cite>float</cite>; default: 1.3050122.e-52)</dt><dd><p>Overwrites the actual quantum parameter used in Maxwell’s QED equations. Assigning a
value here will make the simulation unphysical, but will allow QED effects to become more apparent.
Note that this option will only have an effect if the <code class="docutils literal notranslate"><span class="pre">warpx.use_Hybrid_QED</span></code> flag is also triggered.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_device_synchronize</span></code> (<cite>bool</cite>) optional (default <cite>1</cite>)</dt><dd><p>When running in an accelerated platform, whether to call a <code class="docutils literal notranslate"><span class="pre">amrex::Gpu::synchronize()</span></code> around profiling regions.
This allows the profiler to give meaningful timers, but (hardly) slows down the simulation.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.sort_intervals</span></code> (<cite>string</cite>) optional (defaults: <code class="docutils literal notranslate"><span class="pre">-1</span></code> on CPU; <code class="docutils literal notranslate"><span class="pre">4</span></code> on GPU)</dt><dd><p>Using the <a class="reference internal" href="#intervals-parser">Intervals parser</a> syntax, this string defines the timesteps at which particles are
sorted.
If <code class="docutils literal notranslate"><span class="pre">&lt;=0</span></code>, do not sort particles.
It is turned on on GPUs for performance reasons (to improve memory locality).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.sort_particles_for_deposition</span></code> (<cite>bool</cite>) optional (default: <code class="docutils literal notranslate"><span class="pre">true</span></code> for the CUDA backend, otherwise <code class="docutils literal notranslate"><span class="pre">false</span></code>)</dt><dd><p>This option controls the type of sorting used if particle sorting is turned on, i.e. if <code class="docutils literal notranslate"><span class="pre">sort_intervals</span></code> is not <code class="docutils literal notranslate"><span class="pre">&lt;=0</span></code>.
If <code class="docutils literal notranslate"><span class="pre">true</span></code>, particles will be sorted by cell to optimize deposition with many particles per cell, in the order x -&gt; y -&gt; z -&gt; ppc.
If <code class="docutils literal notranslate"><span class="pre">false</span></code>, particles will be sorted by bin, using the <code class="docutils literal notranslate"><span class="pre">sort_bin_size</span></code> parameter below, in the order ppc -&gt; x -&gt; y -&gt; z.
<code class="docutils literal notranslate"><span class="pre">true</span></code> is recommend for best performance on NVIDIA GPUs, especially if there are many particles per cell.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">warpx.sort_idx_type</span></code> (list of <cite>int</cite>) optional (default: <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">0</span> <span class="pre">0</span></code>)</dt><dd><p>This controls the type of grid used to sort the particles when <code class="docutils literal notranslate"><span class="pre">sort_particles_for_deposition</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>. Possible values are:
<code class="docutils literal notranslate"><span class="pre">idx_type</span> <span class="pre">=</span> <span class="pre">{0,</span> <span class="pre">0,</span> <span class="pre">0}</span></code>: Sort particles to a cell centered grid
<code class="docutils literal notranslate"><span class="pre">idx_type</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">1,</span> <span class="pre">1}</span></code>: Sort particles to a node centered grid
<code class="docutils literal notranslate"><span class="pre">idx_type</span> <span class="pre">=</span> <span class="pre">{2,</span> <span class="pre">2,</span> <span class="pre">2}</span></code>: Compromise between a cell and node centered grid.</p>
<blockquote>
<div><p>In 2D (XZ and RZ), only the first two elements are read.
In 1D, only the first element is read.</p>
</div></blockquote>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.sort_bin_size</span></code> (list of <cite>int</cite>) optional (default <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">1</span> <span class="pre">1</span></code>)</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">sort_intervals</span></code> is activated and <code class="docutils literal notranslate"><span class="pre">sort_particles_for_deposition</span></code> is <code class="docutils literal notranslate"><span class="pre">false</span></code>, particles are sorted in bins of <code class="docutils literal notranslate"><span class="pre">sort_bin_size</span></code> cells.
In 2D, only the first two elements are read.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_shared_mem_charge_deposition</span></code> (<cite>bool</cite>) optional (default <cite>false</cite>)</dt><dd><p>If activated, charge deposition will allocate and use small
temporary buffers on which to accumulate deposited charge values
from particles. On GPUs these buffers will reside in <code class="docutils literal notranslate"><span class="pre">__shared__</span></code>
memory, which is faster than the usual <code class="docutils literal notranslate"><span class="pre">__global__</span></code>
memory. Performance impact will depend on the relative overhead
of assigning the particles to bins small enough to fit in the
space available for the temporary buffers.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_shared_mem_current_deposition</span></code> (<cite>bool</cite>) optional (default <cite>false</cite>)</dt><dd><p>If activated, current deposition will allocate and use small
temporary buffers on which to accumulate deposited current values
from particles. On GPUs these buffers will reside in <code class="docutils literal notranslate"><span class="pre">__shared__</span></code>
memory, which is faster than the usual <code class="docutils literal notranslate"><span class="pre">__global__</span></code>
memory. Performance impact will depend on the relative overhead
of assigning the particles to bins small enough to fit in the
space available for the temporary buffers. Performance is mostly improved
when there is lots of contention between particles writing to the same cell
(e.g. for high particles per cell). This feature is only available for CUDA
and HIP, and is only recommended for 3D or 2D.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.shared_tilesize</span></code> (list of <cite>int</cite>) optional (default <cite>6 6 8</cite> in 3D; <cite>14 14</cite> in 2D; <cite>1s</cite> otherwise)</dt><dd><p>Used to tune performance when <code class="docutils literal notranslate"><span class="pre">do_shared_mem_current_deposition</span></code> or
<code class="docutils literal notranslate"><span class="pre">do_shared_mem_charge_depostion</span></code> is enabled. <code class="docutils literal notranslate"><span class="pre">shared_tilesize</span></code> is the
size of the temporary buffer allocated in shared memory for a threadblock.
A larger tilesize requires more shared memory, but gives more work to each
threadblock, which can lead to higher occupancy, and allows for more
buffered writes to <code class="docutils literal notranslate"><span class="pre">__shared__</span></code> instead of <code class="docutils literal notranslate"><span class="pre">__global__</span></code>. The defaults
in 2D and 3D
are chosen from experimentation, but can be improved upon for specific
problems. The other defaults are not optimized and should always be fine
tuned for the problem.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.shared_mem_current_tpb</span></code> (<cite>int</cite>) optional (default <cite>128</cite>)</dt><dd><p>Used to tune performance when <code class="docutils literal notranslate"><span class="pre">do_shared_mem_current_deposition</span></code> is
enabled. <code class="docutils literal notranslate"><span class="pre">shared_mem_current_tpb</span></code> controls the number of threads per
block (tpb), i.e. the number of threads operating on a shared buffer.</p>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<section id="diagnostics-and-output">
<span id="running-cpp-parameters-diagnostics"></span><h2>Diagnostics and output<a class="headerlink" href="#diagnostics-and-output" title="Link to this heading"></a></h2>
<section id="in-situ-visualization">
<span id="running-cpp-parameters-diagnostics-insitu"></span><h3>In-situ visualization<a class="headerlink" href="#in-situ-visualization" title="Link to this heading"></a></h3>
<p>WarpX has four types of diagnostics:
<code class="docutils literal notranslate"><span class="pre">FullDiagnostics</span></code> consist in dumps of fields and particles at given iterations,
<code class="docutils literal notranslate"><span class="pre">BackTransformedDiagnostics</span></code> are used when running a simulation in a boosted frame, to reconstruct output data to the lab frame,
<code class="docutils literal notranslate"><span class="pre">BoundaryScrapingDiagnostics</span></code> are used to collect the particles that are absorbed at the boundary, throughout the simulation, and
<code class="docutils literal notranslate"><span class="pre">ReducedDiags</span></code> allow the user to compute some reduced quantity (particle temperature, max of a field) and write a small amount of data to text files.
Similar to what is done for physical species, WarpX has a class Diagnostics that allows users to initialize different diagnostics, each of them with different fields, resolution and period.
This currently applies to standard diagnostics, but should be extended to back-transformed diagnostics and reduced diagnostics (and others) in a near future.</p>
</section>
<section id="full-diagnostics">
<span id="running-cpp-parameters-diagnostics-full"></span><h3>Full Diagnostics<a class="headerlink" href="#full-diagnostics" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">FullDiagnostics</span></code> consist in dumps of fields and particles at given iterations.
Similar to what is done for physical species, WarpX has a class Diagnostics that allows users to initialize different diagnostics, each of them with different fields, resolution and period.
The user specifies the number of diagnostics and the name of each of them, and then specifies options for each of them separately.
Note that some parameter (those that do not start with a <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.</span></code> prefix) apply to all diagnostics.
This should be changed in the future.
In-situ capabilities can be used by turning on Sensei or Ascent (provided they are installed) through the output format, see below.</p>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">diagnostics.enable</span></code> (<cite>0</cite> or <cite>1</cite>, optional, default <cite>1</cite>)</dt><dd><p>Whether to enable or disable diagnostics. This flag overwrites all other diagnostics input parameters.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">diagnostics.diags_names</span></code> (list of <cite>string</cite> optional, default <cite>empty</cite>)</dt><dd><p>Name of each diagnostics.
example: <code class="docutils literal notranslate"><span class="pre">diagnostics.diags_names</span> <span class="pre">=</span> <span class="pre">diag1</span> <span class="pre">my_second_diag</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.intervals</span></code> (<cite>string</cite>)</dt><dd><p>Using the <a class="reference internal" href="#intervals-parser">Intervals parser</a> syntax, this string defines the timesteps at which data is dumped.
Use a negative number or 0 to disable data dumping.
example: <code class="docutils literal notranslate"><span class="pre">diag1.intervals</span> <span class="pre">=</span> <span class="pre">10,20:25:1</span></code>.
Note that by default the last timestep is dumped regardless of this parameter. This can be
changed using the parameter <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.dump_last_timestep</span></code> described below.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.dump_last_timestep</span></code> (<cite>bool</cite> optional, default <cite>1</cite>)</dt><dd><p>If this is <cite>1</cite>, the last timestep is dumped regardless of <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.intervals</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> (<cite>string</cite>)</dt><dd><p>Type of diagnostics. <code class="docutils literal notranslate"><span class="pre">Full</span></code>, <code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code>, and <code class="docutils literal notranslate"><span class="pre">BoundaryScraping</span></code>
example: <code class="docutils literal notranslate"><span class="pre">diag1.diag_type</span> <span class="pre">=</span> <span class="pre">Full</span></code> or <code class="docutils literal notranslate"><span class="pre">diag1.diag_type</span> <span class="pre">=</span> <span class="pre">BackTransformed</span></code></p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span></code> (<cite>string</cite> optional, default <code class="docutils literal notranslate"><span class="pre">plotfile</span></code>)</dt><dd><p>Flush format. Possible values are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">plotfile</span></code> for native AMReX format.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">checkpoint</span></code> for a checkpoint file, only works with <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span> <span class="pre">=</span> <span class="pre">Full</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">openpmd</span></code> for OpenPMD format <a class="reference external" href="https://www.openPMD.org">openPMD</a>.
Requires to build WarpX with <code class="docutils literal notranslate"><span class="pre">USE_OPENPMD=TRUE</span></code> (see <a class="reference internal" href="../developers/gnumake/openpmd.html#building-openpmd"><span class="std std-ref">instructions</span></a>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ascent</span></code> for in-situ visualization using Ascent.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sensei</span></code> for in-situ visualization using Sensei.</p></li>
</ul>
<p>example: <code class="docutils literal notranslate"><span class="pre">diag1.format</span> <span class="pre">=</span> <span class="pre">openpmd</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.sensei_config</span></code> (<cite>string</cite>)</dt><dd><p>Only read if <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">sensei</span></code>.
Points to the SENSEI XML file which selects and configures the desired back end.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.sensei_pin_mesh</span></code> (<cite>integer</cite>; 0 by default)</dt><dd><p>Only read if <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">sensei</span></code>.
When 1 lower left corner of the mesh is pinned to 0.,0.,0.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.openpmd_backend</span></code> (<code class="docutils literal notranslate"><span class="pre">bp</span></code>, <code class="docutils literal notranslate"><span class="pre">h5</span></code> or <code class="docutils literal notranslate"><span class="pre">json</span></code>) optional, only used if <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">openpmd</span></code></dt><dd><p><a class="reference external" href="https://openpmd-api.readthedocs.io/en/latest/backends/overview.html">I/O backend</a> for <a class="reference external" href="https://www.openPMD.org">openPMD</a> data dumps.
<code class="docutils literal notranslate"><span class="pre">bp</span></code> is the <a class="reference external" href="https://csmd.ornl.gov/adios">ADIOS I/O library</a>, <code class="docutils literal notranslate"><span class="pre">h5</span></code> is the <a class="reference external" href="https://www.hdfgroup.org/solutions/hdf5/">HDF5 format</a>, and <code class="docutils literal notranslate"><span class="pre">json</span></code> is a <a class="reference external" href="https://en.wikipedia.org/wiki/JSON">simple text format</a>.
<code class="docutils literal notranslate"><span class="pre">json</span></code> only works with serial/single-rank jobs.
When WarpX is compiled with openPMD support, the first available backend in the order given above is taken.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.openpmd_encoding</span></code> (optional, <code class="docutils literal notranslate"><span class="pre">v</span></code> (variable based), <code class="docutils literal notranslate"><span class="pre">f</span></code> (file based) or <code class="docutils literal notranslate"><span class="pre">g</span></code> (group based) ) only read if <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">openpmd</span></code>.</dt><dd><p>openPMD <a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/usage/concepts.html#iteration-and-series">file output encoding</a>.
File based: one file per timestep (slower), group/variable based: one file for all steps (faster)).
<code class="docutils literal notranslate"><span class="pre">variable</span> <span class="pre">based</span></code> is an <a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/backends/adios2.html#experimental-new-adios2-schema">experimental feature with ADIOS2</a> and not supported for back-transformed diagnostics.
Default: <code class="docutils literal notranslate"><span class="pre">f</span></code> (full diagnostics)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.adios2_operator.type</span></code> (<code class="docutils literal notranslate"><span class="pre">zfp</span></code>, <code class="docutils literal notranslate"><span class="pre">blosc</span></code>) optional,</dt><dd><p><a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/details/backendconfig.html#adios2">ADIOS2 I/O operator type</a> for <a class="reference external" href="https://www.openPMD.org">openPMD</a> data dumps.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.adios2_operator.parameters.*</span></code> optional,</dt><dd><p><a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/details/backendconfig.html#adios2">ADIOS2 I/O operator parameters</a> for <a class="reference external" href="https://www.openPMD.org">openPMD</a> data dumps.</p>
<p>A typical example for <a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/details/backendconfig.html#adios2">ADIOS2 output using lossless compression</a> with <code class="docutils literal notranslate"><span class="pre">blosc</span></code> using the <code class="docutils literal notranslate"><span class="pre">zstd</span></code> compressor and 6 CPU treads per MPI Rank (e.g. for a <a class="reference external" href="https://arxiv.org/abs/1706.00522">GPU run with spare CPU resources</a>):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;diag_name&gt;.adios2_operator.type = blosc
&lt;diag_name&gt;.adios2_operator.parameters.compressor = zstd
&lt;diag_name&gt;.adios2_operator.parameters.clevel = 1
&lt;diag_name&gt;.adios2_operator.parameters.doshuffle = BLOSC_BITSHUFFLE
&lt;diag_name&gt;.adios2_operator.parameters.threshold = 2048
&lt;diag_name&gt;.adios2_operator.parameters.nthreads = 6  # per MPI rank (and thus per GPU)
</pre></div>
</div>
<p>or for the lossy ZFP compressor using very strong compression per scalar:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;diag_name&gt;.adios2_operator.type = zfp
&lt;diag_name&gt;.adios2_operator.parameters.precision = 3
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.adios2_engine.type</span></code> (<code class="docutils literal notranslate"><span class="pre">bp4</span></code>, <code class="docutils literal notranslate"><span class="pre">sst</span></code>, <code class="docutils literal notranslate"><span class="pre">ssc</span></code>, <code class="docutils literal notranslate"><span class="pre">dataman</span></code>) optional,</dt><dd><p><a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/details/backendconfig.html#adios2">ADIOS2 Engine type</a> for <a class="reference external" href="https://www.openPMD.org">openPMD</a> data dumps.
See full list of engines at <a class="reference external" href="https://adios2.readthedocs.io/en/latest/engines/engines.html">ADIOS2 readthedocs</a></p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.adios2_engine.parameters.*</span></code> optional,</dt><dd><p><a class="reference external" href="https://openpmd-api.readthedocs.io/en/0.15.1/details/backendconfig.html#adios2">ADIOS2 Engine parameters</a> for <a class="reference external" href="https://www.openPMD.org">openPMD</a> data dumps.</p>
<p>An example for parameters for the BP engine are setting the number of writers (<code class="docutils literal notranslate"><span class="pre">NumAggregators</span></code>), transparently redirecting data to burst buffers etc.
A detailed list of engine-specific parameters are available at the official <a class="reference external" href="https://adios2.readthedocs.io/en/latest/engines/engines.html">ADIOS2 documentation</a></p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>&lt;diag_name&gt;.adios2_engine.parameters.NumAggregators = 2048
&lt;diag_name&gt;.adios2_engine.parameters.BurstBufferPath=&quot;/mnt/bb/username&quot;
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.fields_to_plot</span></code> (list of <cite>strings</cite>, optional)</dt><dd><p>Fields written to output.
Possible scalar fields: <code class="docutils literal notranslate"><span class="pre">part_per_cell</span></code> <code class="docutils literal notranslate"><span class="pre">rho</span></code> <code class="docutils literal notranslate"><span class="pre">phi</span></code> <code class="docutils literal notranslate"><span class="pre">F</span></code> <code class="docutils literal notranslate"><span class="pre">part_per_grid</span></code> <code class="docutils literal notranslate"><span class="pre">divE</span></code> <code class="docutils literal notranslate"><span class="pre">divB</span></code> <code class="docutils literal notranslate"><span class="pre">sigma</span></code> <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> <code class="docutils literal notranslate"><span class="pre">mu</span></code> and <code class="docutils literal notranslate"><span class="pre">rho_&lt;species_name&gt;</span></code>, where <code class="docutils literal notranslate"><span class="pre">&lt;species_name&gt;</span></code> must match the name of one of the available particle species. Note that <code class="docutils literal notranslate"><span class="pre">phi</span></code> will only be written out when do_electrostatic==labframe. Also <code class="docutils literal notranslate"><span class="pre">sigma</span></code> <code class="docutils literal notranslate"><span class="pre">epsilon</span></code>, and <code class="docutils literal notranslate"><span class="pre">mu</span></code> will be written when <cite>algo.em_solver_medium = macroscopic</cite>. Also, note that for <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span> <span class="pre">=</span> <span class="pre">BackTransformed</span></code>, the only scalar field currently supported is <code class="docutils literal notranslate"><span class="pre">rho</span></code>.
Possible vector field components in Cartesian geometry: <code class="docutils literal notranslate"><span class="pre">Ex</span></code> <code class="docutils literal notranslate"><span class="pre">Ey</span></code> <code class="docutils literal notranslate"><span class="pre">Ez</span></code> <code class="docutils literal notranslate"><span class="pre">Bx</span></code> <code class="docutils literal notranslate"><span class="pre">By</span></code> <code class="docutils literal notranslate"><span class="pre">Bz</span></code> <code class="docutils literal notranslate"><span class="pre">jx</span></code> <code class="docutils literal notranslate"><span class="pre">jy</span></code> <code class="docutils literal notranslate"><span class="pre">jz</span></code>.
If compiled with <code class="docutils literal notranslate"><span class="pre">USE_LLG=TRUE</span></code>, additional vector fields components include
<code class="docutils literal notranslate"><span class="pre">Hx</span></code> <code class="docutils literal notranslate"><span class="pre">Hy</span></code> <code class="docutils literal notranslate"><span class="pre">Hz</span></code>
<code class="docutils literal notranslate"><span class="pre">Mx_xface</span></code> <code class="docutils literal notranslate"><span class="pre">Mx_yface</span></code> <code class="docutils literal notranslate"><span class="pre">Mx_zface</span></code>
<code class="docutils literal notranslate"><span class="pre">My_xface</span></code> <code class="docutils literal notranslate"><span class="pre">My_yface</span></code> <code class="docutils literal notranslate"><span class="pre">My_zface</span></code>
<code class="docutils literal notranslate"><span class="pre">Mz_xface</span></code> <code class="docutils literal notranslate"><span class="pre">Mz_yface</span></code> <code class="docutils literal notranslate"><span class="pre">Mz_zface</span></code>
Additional scalar fields components include
<code class="docutils literal notranslate"><span class="pre">mag_Ms_xface</span></code>       <code class="docutils literal notranslate"><span class="pre">mag_Ms_yface</span></code>       <code class="docutils literal notranslate"><span class="pre">mag_Ms_zface</span></code>
<code class="docutils literal notranslate"><span class="pre">mag_alpha_xface</span></code>    <code class="docutils literal notranslate"><span class="pre">mag_alpha_yface</span></code>    <code class="docutils literal notranslate"><span class="pre">mag_alpha_zface</span></code>
<code class="docutils literal notranslate"><span class="pre">mag_exchange_xface</span></code> <code class="docutils literal notranslate"><span class="pre">mag_exchange_yface</span></code> <code class="docutils literal notranslate"><span class="pre">mag_exchange_zface</span></code>
<code class="docutils literal notranslate"><span class="pre">mag_anisotropy_xface</span></code> <code class="docutils literal notranslate"><span class="pre">mag_anisotropy_yface</span></code> <code class="docutils literal notranslate"><span class="pre">mag_anisotropy_zface</span></code>
For superconducting physics we also include
<code class="docutils literal notranslate"><span class="pre">superconductor</span></code>
<code class="docutils literal notranslate"><span class="pre">Bx_sc</span></code> <code class="docutils literal notranslate"><span class="pre">By_sc</span></code> <code class="docutils literal notranslate"><span class="pre">Bz_sc</span></code></p>
<p>Possible vector field components in RZ geometry: <code class="docutils literal notranslate"><span class="pre">Er</span></code> <code class="docutils literal notranslate"><span class="pre">Et</span></code> <code class="docutils literal notranslate"><span class="pre">Ez</span></code> <code class="docutils literal notranslate"><span class="pre">Br</span></code> <code class="docutils literal notranslate"><span class="pre">Bt</span></code> <code class="docutils literal notranslate"><span class="pre">Bz</span></code> <code class="docutils literal notranslate"><span class="pre">jr</span></code> <code class="docutils literal notranslate"><span class="pre">jt</span></code> <code class="docutils literal notranslate"><span class="pre">jz</span></code>.
The default is <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.fields_to_plot</span> <span class="pre">=</span> <span class="pre">Ex</span> <span class="pre">Ey</span> <span class="pre">Ez</span> <span class="pre">Bx</span> <span class="pre">By</span> <span class="pre">Bz</span> <span class="pre">jx</span> <span class="pre">jy</span> <span class="pre">jz</span></code> in Cartesian geometry and <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.fields_to_plot</span> <span class="pre">=</span> <span class="pre">Er</span> <span class="pre">Et</span> <span class="pre">Ez</span> <span class="pre">Br</span> <span class="pre">Bt</span> <span class="pre">Bz</span> <span class="pre">jr</span> <span class="pre">jt</span> <span class="pre">jz</span></code> in RZ geometry.
When the special value <code class="docutils literal notranslate"><span class="pre">none</span></code> is specified, no fields are written out.
Note that the fields are averaged on the cell centers before they are written to file.
Otherwise, we reconstruct a 2D Cartesian slice of the fields for output at <span class="math notranslate nohighlight">\(\theta=0\)</span>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.dump_rz_modes</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Whether to save all modes when in RZ.  When <code class="docutils literal notranslate"><span class="pre">openpmd_backend</span> <span class="pre">=</span> <span class="pre">openpmd</span></code>, this parameter is ignored and all modes are saved.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields_to_plot</span></code> (list of <cite>strings</cite>, optional)</dt><dd><p>Names of per-cell diagnostics of particle properties to calculate and output as additional fields.
Note that the deposition onto the grid does not respect the particle shape factor, but instead uses nearest-grid point interpolation.
Default is none.
Parser functions for these field names are specified by <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields.&lt;field_name&gt;(x,y,z,ux,uy,uz)</span></code>.
Also, note that this option is only available for <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span> <span class="pre">=</span> <span class="pre">Full</span></code></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields_species</span></code> (list of <cite>strings</cite>, optional)</dt><dd><p>Species for which to calculate <code class="docutils literal notranslate"><span class="pre">particle_fields_to_plot</span></code>.
Fields will be calculated separately for each specified species.
The default is a list of all of the available particle species.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields.&lt;field_name&gt;.do_average</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>1</cite>)</dt><dd><p>Whether the diagnostic is an average or a sum. With an average, the sum over the specified function is divided
by the sum of the particle weights in each cell.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields.&lt;field_name&gt;(x,y,z,ux,uy,uz)</span></code> (parser <cite>string</cite>)</dt><dd><p>Parser function to be calculated for each particle per cell. The averaged field written is</p>
<div class="math notranslate nohighlight">
\[\texttt{&lt;field_name&gt;_&lt;species&gt;} = \frac{\sum_{i=1}^N w_i \, f(x_i,y_i,z_i,u_{x,i},u_{y,i},u_{z,i})}{\sum_{i=1}^N w_i}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span> is the particle weight, <span class="math notranslate nohighlight">\(f()\)</span> is the parser function, and <span class="math notranslate nohighlight">\((x_i,y_i,z_i)\)</span> are particle positions in units of a meter. The sums are over all particles of type <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;</span></code> in a cell (ignoring the particle shape factor) that satisfy <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields.&lt;field_name&gt;.filter(x,y,z,ux,uy,uz)</span></code>.
When <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields.&lt;field_name&gt;.do_average</span></code> is <cite>0</cite>, the division by the sum over particle weights is not done.
In 1D or 2D, the particle coordinates will follow the WarpX convention. <span class="math notranslate nohighlight">\((u_{x,i},u_{y,i},u_{z,i})\)</span> are components of the particle four-velocity. <span class="math notranslate nohighlight">\(u = \gamma v/c\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor, <span class="math notranslate nohighlight">\(v\)</span> is the particle velocity, and <span class="math notranslate nohighlight">\(c\)</span> is the speed of light.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.particle_fields.&lt;field_name&gt;.filter(x,y,z,ux,uy,uz)</span></code> (parser <cite>string</cite>, optional)</dt><dd><p>Parser function returning a boolean for whether to include a particle in the diagnostic.
If not specified, all particles will be included (see above).
The function arguments are the same as above.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.plot_raw_fields</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>By default, the fields written in the plot files are averaged on the cell centers.
When <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.plot_raw_fields</span> <span class="pre">=</span> <span class="pre">1</span></code>, then the raw (i.e. non-averaged)
fields are also saved in the output files.
Only works with <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">plotfile</span></code>.
See <a class="reference external" href="https://yt-project.org/doc/examining/loading_data.html#viewing-raw-fields-in-warpx">this section</a>
in the yt documentation for more details on how to view raw fields.
If compiled with <code class="docutils literal notranslate"><span class="pre">USE_LLG=TRUE</span></code>, <code class="docutils literal notranslate"><span class="pre">M_xface</span></code> <code class="docutils literal notranslate"><span class="pre">M_yface</span></code> and <code class="docutils literal notranslate"><span class="pre">M_zface</span></code>
are also output, where each of these are face-centered and contain all three
components of the M-field.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.plot_raw_fields_guards</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.plot_raw_fields</span> <span class="pre">=</span> <span class="pre">1</span></code>.
Whether to include the guard cells in the output of the raw fields.
Only works with <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">plotfile</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.plot_raw_rho</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</p></li>
</ul>
<p>By default, the charge density written in the plot files is averaged on the cell centers.
When <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.plot_raw_rho</span> <span class="pre">=</span> <span class="pre">1</span></code>, then the raw (i.e. non-averaged) charge density is also saved in the output files.
Only works with <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">plotfile</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.coarsening_ratio</span></code> (list of <cite>int</cite>) optional (default <cite>1 1 1</cite>)</dt><dd><p>Reduce size of the field output by this ratio in each dimension.
(This is done by averaging the field over 1 or 2 points along each direction, depending on the staggering).
If <code class="docutils literal notranslate"><span class="pre">blocking_factor</span></code> and <code class="docutils literal notranslate"><span class="pre">max_grid_size</span></code> are used for the domain decomposition, as detailed in
the <a class="reference internal" href="domain_decomposition.html#usage-domain-decomposition"><span class="std std-ref">domain decomposition</span></a> section, <code class="docutils literal notranslate"><span class="pre">coarsening_ratio</span></code> should be an integer
divisor of <code class="docutils literal notranslate"><span class="pre">blocking_factor</span></code>. If <code class="docutils literal notranslate"><span class="pre">warpx.numprocs</span></code> is used instead, the total number of cells in a given
dimension must be a multiple of the <code class="docutils literal notranslate"><span class="pre">coarsening_ratio</span></code> multiplied by <code class="docutils literal notranslate"><span class="pre">numprocs</span></code> in that dimension.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.file_prefix</span></code> (<cite>string</cite>) optional (default <cite>diags/&lt;diag_name&gt;</cite>)</dt><dd><p>Root for output file names. Supports sub-directories.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.file_min_digits</span></code> (<cite>int</cite>) optional (default <cite>6</cite>)</dt><dd><p>The minimum number of digits used for the iteration number appended to the diagnostic file names.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_lo</span></code> (list <cite>float</cite>, 1 per dimension) optional (default <cite>-infinity -infinity -infinity</cite>)</dt><dd><p>Lower corner of the output fields (if smaller than <code class="docutils literal notranslate"><span class="pre">warpx.dom_lo</span></code>, then set to <code class="docutils literal notranslate"><span class="pre">warpx.dom_lo</span></code>). Currently, when the <code class="docutils literal notranslate"><span class="pre">diag_lo</span></code> is different from <code class="docutils literal notranslate"><span class="pre">warpx.dom_lo</span></code>, particle output is disabled.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_hi</span></code> (list <cite>float</cite>, 1 per dimension) optional (default <cite>+infinity +infinity +infinity</cite>)</dt><dd><p>Higher corner of the output fields (if larger than <code class="docutils literal notranslate"><span class="pre">warpx.dom_hi</span></code>, then set to <code class="docutils literal notranslate"><span class="pre">warpx.dom_hi</span></code>). Currently, when the <code class="docutils literal notranslate"><span class="pre">diag_hi</span></code> is different from <code class="docutils literal notranslate"><span class="pre">warpx.dom_hi</span></code>, particle output is disabled.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.write_species</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>1</cite>)</dt><dd><p>Whether to write species output or not. For checkpoint format, always set this parameter to 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.species</span></code> (list of <cite>string</cite>, default all physical species in the simulation)</dt><dd><p>Which species dumped in this diagnostics.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.variables</span></code> (list of <cite>strings</cite> separated by spaces, optional)</dt><dd><p>List of particle quantities to write to output.
Choices are <code class="docutils literal notranslate"><span class="pre">w</span></code> for the particle weight and <code class="docutils literal notranslate"><span class="pre">ux</span></code> <code class="docutils literal notranslate"><span class="pre">uy</span></code> <code class="docutils literal notranslate"><span class="pre">uz</span></code> for the particle momenta.
By default, all particle quantities are written.
If <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.variables</span> <span class="pre">=</span> <span class="pre">none</span></code>, no particle data are written, except for particle positions, which are always included.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.random_fraction</span></code> (<cite>float</cite>) optional</dt><dd><p>If provided <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.random_fraction</span> <span class="pre">=</span> <span class="pre">a</span></code>, only <cite>a</cite> fraction of the particle data of this species will be dumped randomly in diag <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;</span></code>, i.e. if <cite>rand() &lt; a</cite>, this particle will be dumped, where <cite>rand()</cite> denotes a random number generator.
The value <cite>a</cite> provided should be between 0 and 1.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.uniform_stride</span></code> (<cite>int</cite>) optional</dt><dd><p>If provided <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.uniform_stride</span> <span class="pre">=</span> <span class="pre">n</span></code>,
every <cite>n</cite> particle of this species will be dumped, selected uniformly.
The value provided should be an integer greater than or equal to 0.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.&lt;species_name&gt;.plot_filter_function(t,x,y,z,ux,uy,uz)</span></code> (<cite>string</cite>) optional</dt><dd><p>Users can provide an expression returning a boolean for whether a particle is dumped.
<cite>t</cite> represents the physical time in seconds during the simulation.
<cite>x, y, z</cite> represent particle positions in the unit of meter.
<cite>ux, uy, uz</cite> represent particle velocities in the unit of
<span class="math notranslate nohighlight">\(\gamma v/c\)</span>, where
<span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor,
<span class="math notranslate nohighlight">\(v/c\)</span> is the particle velocity normalized by the speed of light.
E.g. If provided <cite>(x&gt;0.0)*(uz&lt;10.0)</cite> only those particles located at
positions <cite>x</cite> greater than <cite>0</cite>, and those having velocity <cite>uz</cite> less than 10,
will be dumped.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amrex.async_out</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Whether to use asynchronous IO when writing plotfiles. This only has an effect
when using the AMReX plotfile format.
Please see the <a class="reference internal" href="../dataanalysis/formats.html#dataanalysis-formats"><span class="std std-ref">data analysis section</span></a> for more information.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amrex.async_out_nfiles</span></code> (<cite>int</cite>) optional (default <cite>64</cite>)</dt><dd><p>The maximum number of files to write to when using asynchronous IO.
To use asynchronous IO with more than <code class="docutils literal notranslate"><span class="pre">amrex.async_out_nfiles</span></code> MPI ranks,
WarpX must be configured with <code class="docutils literal notranslate"><span class="pre">-DWarpX_MPI_THREAD_MULTIPLE=ON</span></code>.
Please see the <a class="reference internal" href="../dataanalysis/formats.html#dataanalysis-formats"><span class="std std-ref">data analysis section</span></a> for more information.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.field_io_nfiles</span></code> and <code class="docutils literal notranslate"><span class="pre">warpx.particle_io_nfiles</span></code> (<cite>int</cite>) optional (default <cite>1024</cite>)</dt><dd><p>The maximum number of files to use when writing field and particle data to plotfile directories.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.mffile_nstreams</span></code> (<cite>int</cite>) optional (default <cite>4</cite>)</dt><dd><p>Limit the number of concurrent readers per file.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="backtransformed-diagnostics">
<span id="running-cpp-parameters-diagnostics-btd"></span><h3>BackTransformed Diagnostics<a class="headerlink" href="#backtransformed-diagnostics" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code> diag type are used when running a simulation in a boosted frame, to reconstruct output data to the lab frame. This option can be set using <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span> <span class="pre">=</span> <span class="pre">BackTransformed</span></code>. Note that this diagnostic is not currently supported for RZ.  Additional options for this diagnostic include:</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.num_snapshots_lab</span></code> (<cite>integer</cite>)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> is <code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code>.
The number of lab-frame snapshots that will be written.
Only this option or <code class="docutils literal notranslate"><span class="pre">intervals</span></code> should be specified;
a run-time error occurs if the user attempts to set both <code class="docutils literal notranslate"><span class="pre">num_snapshots_lab</span></code> and <code class="docutils literal notranslate"><span class="pre">intervals</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.intervals</span></code> (<cite>string</cite>)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> is <code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code>.
Using the <a class="reference internal" href="#intervals-parser">Intervals parser</a> syntax, this string defines the lab frame times at which data is dumped,
given as multiples of the step size <code class="docutils literal notranslate"><span class="pre">dt_snapshots_lab</span></code> or <code class="docutils literal notranslate"><span class="pre">dz_snapshots_lab</span></code> described below.
Example: <code class="docutils literal notranslate"><span class="pre">btdiag1.intervals</span> <span class="pre">=</span> <span class="pre">10:11,20:24:2</span></code> and <code class="docutils literal notranslate"><span class="pre">btdiag1.dt_snapshots_lab</span> <span class="pre">=</span> <span class="pre">1.e-12</span></code>
indicate to dump at lab times <code class="docutils literal notranslate"><span class="pre">1e-11</span></code>, <code class="docutils literal notranslate"><span class="pre">1.1e-11</span></code>, <code class="docutils literal notranslate"><span class="pre">2e-11</span></code>, <code class="docutils literal notranslate"><span class="pre">2.2e-11</span></code>, and <code class="docutils literal notranslate"><span class="pre">2.4e-11</span></code> seconds.
Note that the stop interval, the second number in the slice, must always be specified.
Only this option or <code class="docutils literal notranslate"><span class="pre">num_snapshots_lab</span></code> should be specified;
a run-time error occurs if the user attempts to set both <code class="docutils literal notranslate"><span class="pre">num_snapshots_lab</span></code> and <code class="docutils literal notranslate"><span class="pre">intervals</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.dt_snapshots_lab</span></code> (<cite>float</cite>, in seconds)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> is <code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code>.
The time interval in between the lab-frame snapshots (where this
time interval is expressed in the laboratory frame).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.dz_snapshots_lab</span></code> (<cite>float</cite>, in meters)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> is <code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code>.
Distance between the lab-frame snapshots (expressed in the laboratory
frame). <code class="docutils literal notranslate"><span class="pre">dt_snapshots_lab</span></code> is then computed by
<code class="docutils literal notranslate"><span class="pre">dt_snapshots_lab</span> <span class="pre">=</span> <span class="pre">dz_snapshots_lab/c</span></code>. Either <cite>dt_snapshots_lab</cite>
or <cite>dz_snapshot_lab</cite> is required.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.buffer_size</span></code> (<cite>integer</cite>)</dt><dd><p>Only used when <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> is <code class="docutils literal notranslate"><span class="pre">BackTransformed</span></code>.
The default size of the back transformed diagnostic buffers used to generate lab-frame
data is 256. That is, when the multifab with lab-frame data has 256 z-slices,
the data will be flushed out. However, if many lab-frame snapshots are required for
diagnostics and visualization, the GPU may run out of memory with many large boxes with
a size of 256 in the z-direction. This input parameter can then be used to set a
smaller buffer-size, preferably multiples of 8, such that, a large number of
lab-frame snapshot data can be generated without running out of gpu memory.
The downside to using a small buffer size, is that the I/O time may increase due
to frequent flushes of the lab-frame data. The other option is to keep the default
value for buffer size and use slices to reduce the memory footprint and maintain
optimum I/O performance.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="boundary-scraping-diagnostics">
<h3>Boundary Scraping Diagnostics<a class="headerlink" href="#boundary-scraping-diagnostics" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">BoundaryScrapingDiagnostics</span></code> are used to collect the particles that are absorbed at the boundaries, throughout the simulation.
This diagnostic type is specified by setting <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.diag_type</span></code> = <code class="docutils literal notranslate"><span class="pre">BoundaryScraping</span></code>.
Currently, the only supported output format is openPMD, so the user also needs to set <code class="docutils literal notranslate"><span class="pre">&lt;diag&gt;.format=openpmd</span></code> and WarpX must be compiled with openPMD turned on.
The data that is to be collected and recorded is controlled per species and per boundary by setting one or more of the flags to <code class="docutils literal notranslate"><span class="pre">1</span></code>,
<code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.save_particles_at_xlo/ylo/zlo</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.save_particles_at_xhi/yhi/zhi</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;species&gt;.save_particles_at_eb</span></code>.
(Note that this diagnostics does not save any field ; it only saves particles.)</p>
<p>The data collected at each boundary is written out to a subdirectory of the diagnostics directory with the name of the boundary, for example, <code class="docutils literal notranslate"><span class="pre">particles_at_xlo</span></code>, <code class="docutils literal notranslate"><span class="pre">particles_at_zhi</span></code>, or <code class="docutils literal notranslate"><span class="pre">particles_at_eb</span></code>.
By default, all of the collected particle data is written out at the end of the simulation. Optionally, the <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.intervals</span></code> parameter can be given to specify writing out the data more often.
This can be important if a large number of particles are lost, avoiding filling up memory with the accumulated lost particle data.</p>
<p>In addition to their usual attributes, the saved particles have an integer attribute <code class="docutils literal notranslate"><span class="pre">timestamp</span></code>, which
indicates the PIC iteration at which each particle was absorbed at the boundary.</p>
</section>
<section id="reduced-diagnostics">
<span id="running-cpp-parameters-diagnostics-reduced"></span><h3>Reduced Diagnostics<a class="headerlink" href="#reduced-diagnostics" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">ReducedDiags</span></code> allow the user to compute some reduced quantity (particle temperature, max of a field) and write a small amount of data to text files.</p>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.reduced_diags_names</span></code> (<cite>strings</cite>, separated by spaces)</dt><dd><p>The names given by the user of simple reduced diagnostics.
Also the names of the output <cite>.txt</cite> files.
This reduced diagnostics aims to produce simple outputs
of the time history of some physical quantities.
If <code class="docutils literal notranslate"><span class="pre">warpx.reduced_diags_names</span></code> is not provided in the input file,
no reduced diagnostics will be done.
This is then used in the rest of the input deck;
in this documentation we use <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;</span></code> as a placeholder.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.type</span></code> (<cite>string</cite>)</dt><dd><p>The type of reduced diagnostics associated with this <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;</span></code>.
For example, <code class="docutils literal notranslate"><span class="pre">ParticleEnergy</span></code>, <code class="docutils literal notranslate"><span class="pre">FieldEnergy</span></code>, etc.
All available types are described below in detail.
For all reduced diagnostics,
the first and the second columns in the output file are
the time step and the corresponding physical time in seconds, respectively.</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ParticleEnergy</span></code></dt><dd><p>This type computes the total and mean relativistic particle kinetic energy among all species:</p>
<div class="math notranslate nohighlight">
\[E_p = \sum_{i=1}^N w_i \, \left( \sqrt{|\boldsymbol{p}_i|^2 c^2 + m_0^2 c^4} - m_0 c^2 \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{p}_i\)</span> is the relativistic momentum of the <span class="math notranslate nohighlight">\(i\)</span>-th particle, <span class="math notranslate nohighlight">\(c\)</span> is the speed of light, <span class="math notranslate nohighlight">\(m_0\)</span> is the rest mass, <span class="math notranslate nohighlight">\(N\)</span> is the number of particles, and <span class="math notranslate nohighlight">\(w_i\)</span> is the weight of the <span class="math notranslate nohighlight">\(i\)</span>-th particle.</p>
<p>The output columns are the total energy of all species, the total energy per species, the total mean energy <span class="math notranslate nohighlight">\(E_p / \sum_i w_i\)</span> of all species, and the total mean energy per species.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ParticleMomentum</span></code></dt><dd><p>This type computes the total and mean relativistic particle momentum among all species:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{P}_p = \sum_{i=1}^N w_i \, \boldsymbol{p}_i\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{p}_i\)</span> is the relativistic momentum of the <span class="math notranslate nohighlight">\(i\)</span>-th particle, <span class="math notranslate nohighlight">\(N\)</span> is the number of particles, and <span class="math notranslate nohighlight">\(w_i\)</span> is the weight of the <span class="math notranslate nohighlight">\(i\)</span>-th particle.</p>
<p>The output columns are the components of the total momentum of all species, the total momentum per species, the total mean momentum <span class="math notranslate nohighlight">\(\boldsymbol{P}_p / \sum_i w_i\)</span> of all species, and the total mean momentum per species.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">FieldEnergy</span></code></dt><dd><p>This type computes the electromagnetic field energy</p>
<div class="math notranslate nohighlight">
\[E_f = \frac{1}{2} \sum_{\text{cells}} \left( \varepsilon_0 |\boldsymbol{E}|^2 + \frac{|\boldsymbol{B}|^2}{\mu_0} \right) \Delta V\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{E}\)</span> is the electric field, <span class="math notranslate nohighlight">\(\boldsymbol{B}\)</span> is the magnetic field, <span class="math notranslate nohighlight">\(\varepsilon_0\)</span> is the vacuum permittivity, <span class="math notranslate nohighlight">\(\mu_0\)</span> is the vacuum permeability, <span class="math notranslate nohighlight">\(\Delta V\)</span> is the cell volume (or cell area in 2D), and the sum is over all cells.</p>
<p>The output columns are the total field energy <span class="math notranslate nohighlight">\(E_f\)</span>, the <span class="math notranslate nohighlight">\(\boldsymbol{E}\)</span> field energy, and the <span class="math notranslate nohighlight">\(\boldsymbol{B}\)</span> field energy, at each mesh refinement level.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">FieldMomentum</span></code></dt><dd><p>This type computes the electromagnetic field momentum</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{P}_f = \varepsilon_0 \sum_{\text{cells}} \left( \boldsymbol{E} \times \boldsymbol{B} \right) \Delta V\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{E}\)</span> is the electric field, <span class="math notranslate nohighlight">\(\boldsymbol{B}\)</span> is the magnetic field, <span class="math notranslate nohighlight">\(\varepsilon_0\)</span> is the vacuum permittivity, <span class="math notranslate nohighlight">\(\Delta V\)</span> is the cell volume (or cell area in 2D), and the sum is over all cells.</p>
<p>The output columns are the components of the total field momentum <span class="math notranslate nohighlight">\(\boldsymbol{P}_f\)</span> at each mesh refinement level.</p>
<p>Note that the fields are <em>not</em> averaged on the cell centers before their energy is
computed.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">FieldMaximum</span></code></dt><dd><p>This type computes the maximum value of each component of the electric and magnetic fields
and of the norm of the electric and magnetic field vectors.
Measuring maximum fields in a plasma might be very noisy in PIC, use this instead
for analysis of scenarios such as an electromagnetic wave propagating in vacuum.</p>
<p>The output columns are
the maximum value of the <span class="math notranslate nohighlight">\(E_x\)</span> field,
the maximum value of the <span class="math notranslate nohighlight">\(E_y\)</span> field,
the maximum value of the <span class="math notranslate nohighlight">\(E_z\)</span> field,
the maximum value of the norm <span class="math notranslate nohighlight">\(|E|\)</span> of the electric field,
the maximum value of the <span class="math notranslate nohighlight">\(B_x\)</span> field,
the maximum value of the <span class="math notranslate nohighlight">\(B_y\)</span> field,
the maximum value of the <span class="math notranslate nohighlight">\(B_z\)</span> field and
the maximum value of the norm <span class="math notranslate nohighlight">\(|B|\)</span> of the magnetic field,
at mesh refinement levels from  0 to <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Note that the fields are averaged on the cell centers before their maximum values are
computed.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">FieldProbe</span></code></dt><dd><p>This type computes the value of each component of the electric and magnetic fields
and of the Poynting vector (a measure of electromagnetic flux) at points in the domain.</p>
<p>Multiple geometries for point probes can be specified via <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.probe_geometry</span> <span class="pre">=</span> <span class="pre">...</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Point</span></code> (default): a single point</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Line</span></code>: a line of points with equal spacing</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Plane</span></code>: a plane of points with equal spacing</p></li>
</ul>
<p><strong>Point</strong>: The point where the fields are measured is specified through the input parameters <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.x_probe</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.y_probe</span></code> and <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.z_probe</span></code>.</p>
<p><strong>Line</strong>: probe a 1 dimensional line of points to create a line detector.
Initial input parameters <code class="docutils literal notranslate"><span class="pre">x_probe</span></code>, <code class="docutils literal notranslate"><span class="pre">y_probe</span></code>, and <code class="docutils literal notranslate"><span class="pre">z_probe</span></code> designate one end of the line detector, while the far end is specified via <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.x1_probe</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.y1_probe</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.z1_probe</span></code>.
Additionally, <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.resolution</span></code> must be defined to give the number of detector points along the line (equally spaced) to probe.</p>
<p><strong>Plane</strong>: probe a 2 dimensional plane of points to create a square plane detector.
Initial input parameters <code class="docutils literal notranslate"><span class="pre">x_probe</span></code>, <code class="docutils literal notranslate"><span class="pre">y_probe</span></code>, and <code class="docutils literal notranslate"><span class="pre">z_probe</span></code> designate the center of the detector.
The detector plane is normal to a vector specified by <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.target_normal_x</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.target_normal_y</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.target_normal_z</span></code>.
Note that it is not necessary to specify the <code class="docutils literal notranslate"><span class="pre">target_normal</span></code> vector in a 2D simulation (the only supported normal is in <code class="docutils literal notranslate"><span class="pre">y</span></code>).
The top of the plane is perpendicular to an “up” vector denoted by <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.target_up_x</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.target_up_y</span></code>, and <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.target_up_z</span></code>.
The detector has a square radius to be determined by <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.detector_radius</span></code>.
Similarly to the line detector, the plane detector requires a resolution <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.resolution</span></code>, which denotes the number of detector particles along each side of the square detector.</p>
<p>The output columns are
the value of the <span class="math notranslate nohighlight">\(E_x\)</span> field,
the value of the <span class="math notranslate nohighlight">\(E_y\)</span> field,
the value of the <span class="math notranslate nohighlight">\(E_z\)</span> field,
the value of the <span class="math notranslate nohighlight">\(B_x\)</span> field,
the value of the <span class="math notranslate nohighlight">\(B_y\)</span> field,
the value of the <span class="math notranslate nohighlight">\(B_z\)</span> field and
the value of the Poynting Vector <span class="math notranslate nohighlight">\(|S|\)</span> of the electromagnetic fields,
at mesh refinement levels from  0 to <span class="math notranslate nohighlight">\(n\)</span>, at point (<span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span>).</p>
<p>Note: the norms are always interpolated to the measurement point before they are written
to file. The electromagnetic field components are interpolated to the measurement point
by default, but can they be saved as non-averaged by setting
<code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.raw_fields</span> <span class="pre">=</span> <span class="pre">true</span></code>, in which case the raw fields for the cell
containing the measurement point are saved.
The interpolation order can be set by specifying <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.interp_order</span></code>,
otherwise it is set to <code class="docutils literal notranslate"><span class="pre">1</span></code>.
Integrated electric and magnetic field components can instead be obtained by specifying
<code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.integrate</span> <span class="pre">==</span> <span class="pre">true</span></code>.
In a <em>moving window</em> simulation, the FieldProbe can be set to follow the moving frame by specifying <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.do_moving_window_FP</span> <span class="pre">=</span> <span class="pre">1</span></code> (default 0).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The FieldProbe reduced diagnostic does not yet add a Lorentz back transformation for boosted frame simulations.
Thus, it records field data in the boosted frame, not (yet) in the lab frame.</p>
</div>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">RhoMaximum</span></code></dt><dd><p>This type computes the maximum and minimum values of the total charge density as well as
the maximum absolute value of the charge density of each charged species.
Please be aware that measuring maximum charge densities might be very noisy in PIC simulations.</p>
<p>The output columns are
the maximum value of the <span class="math notranslate nohighlight">\(rho\)</span> field,
the minimum value of the <span class="math notranslate nohighlight">\(rho\)</span> field,
the maximum value of the absolute <span class="math notranslate nohighlight">\(|rho|\)</span> field of each charged species.</p>
<p>Note that the charge densities are averaged on the cell centers before their maximum values
are computed.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">FieldReduction</span></code></dt><dd><p>This type computes an arbitrary reduction of the positions and the electromagnetic fields.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduced_function(x,y,z,Ex,Ey,Ez,Bx,By,Bz)</span></code> (<cite>string</cite>)</dt><dd><p>An analytic function to be reduced must be provided, using the math parser.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduction_type</span></code> (<cite>string</cite>)</dt><dd><p>The type of reduction to be performed. It must be either <code class="docutils literal notranslate"><span class="pre">Maximum</span></code>, <code class="docutils literal notranslate"><span class="pre">Minimum</span></code> or
<code class="docutils literal notranslate"><span class="pre">Integral</span></code>.
<code class="docutils literal notranslate"><span class="pre">Integral</span></code> computes the spatial integral of the function defined in the parser by
summing its value on all grid points and multiplying the result by the volume of a
cell.
Please be also aware that measuring maximum quantities might be very noisy in PIC
simulations.</p>
</dd>
</dl>
</li>
</ul>
<p>The only output column is the reduced value.</p>
<p>Note that the fields are averaged on the cell centers before the reduction is performed.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">RawEFieldReduction</span></code></dt><dd><p>This type is ONLY for the E-field at their respective staggering on the Yee-grid (or the type of grid used in the
simulation) and executes the <code class="docutils literal notranslate"><span class="pre">reduced_function</span></code> which is a user-defined analytic function as given below.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduced_function(x,y,z)</span></code> (<cite>string</cite>)</dt><dd><p>An analytic function used to select the region over which the electric fields will be reduced using
the <code class="docutils literal notranslate"><span class="pre">reduction_type</span></code> described below.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduction_type</span></code> (<cite>string</cite>)</dt><dd><p>The type of reduction to be performed. It must be either <code class="docutils literal notranslate"><span class="pre">Maximum</span></code>, <code class="docutils literal notranslate"><span class="pre">Minimum</span></code> or
<code class="docutils literal notranslate"><span class="pre">Integral</span></code>.
<code class="docutils literal notranslate"><span class="pre">Integral</span></code> computes the spatial surface or volume integral, depending on the choice
of the <code class="docutils literal notranslate"><span class="pre">integration_type</span></code>, of the function defined in the parser by summing its value on
all grid points and multiplying the result by the area or volume of a cell.
Please be also aware that measuring maximum quantities might be very noisy in PIC
simulations.</p>
</dd>
</dl>
</li>
</ul>
<p>The output columns correspond to the timestep counter, physical time, and reduced values of Ex, Ey, Ez components.</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.integration_type</span></code> (<cite>string</cite>)</dt><dd><p>The type of integration to be performed. It must be either <code class="docutils literal notranslate"><span class="pre">surface</span></code> or <code class="docutils literal notranslate"><span class="pre">volume</span></code>.
Note that the surface integral provides the integrated normal as well as the
traverse fields over the surface. For the surface integral, the user-defined parser
for the plane should be less than one cell size in thickness in the direction of the surface normal.
Also, if the surface to be defined has an edge that overlaps with the domain boundary but the edge parallel
to it does not overlap with the domain boundary, e.g. a half cross-section of a plane, then exclude the
edge that overlaps with the domain boundary while defining the surface.</p>
<p>For example, we can define a surface on a y-plane at a location, <cite>y_plane_location</cite>, having a half cross-section
from z=-Lz/2 to 0, where Lz is the length of the domain in the z-direction spanning from -Lz/2 to Lz/2, as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduced_function(x,y,z)</span> <span class="pre">=</span> <span class="pre">&quot;</span> <span class="pre">(y</span> <span class="pre">&gt;</span> <span class="pre">y_plane_location</span> <span class="pre">-</span> <span class="pre">dy/2.-epsilon)</span> <span class="pre">*</span> <span class="pre">(y</span> <span class="pre">&lt;</span> <span class="pre">y_plane_location+epsilon)</span> <span class="pre">*</span> <span class="pre">(z</span> <span class="pre">&gt;</span> <span class="pre">-Lz/2.)</span> <span class="pre">*</span> <span class="pre">(z</span> <span class="pre">&lt;</span> <span class="pre">0.+epsilon)</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">&quot;</span></code></p>
<p>In this example, epsilon is a very small number which is larger than machine precision.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.surface_normal</span></code> (<cite>string</cite>)</dt><dd><p>The surface on which the surface integration is required. It must be either <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">z</span></code>.
The direction of the normal is positive in the Cartesian directions.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.scaling_factor</span></code> (<cite>string</cite>) optional (default <cite>1 1 1</cite>)</dt><dd><p>This parameter is used when the <code class="docutils literal notranslate"><span class="pre">integration_type</span></code> is set to <code class="docutils literal notranslate"><span class="pre">surface</span></code>. The parser takes three values to scale
the reduced field quantities, namely, the surface integral of Ex, Ey, and Ez.
This parameter can be used in the following two scenarios:
Let’s say, we require the surface integral of Ex on a surface, with the surface normal in the negative x-direction.
In that case, we would specify the value of this parameter as <code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">1</span> <span class="pre">1</span></code> so that the surface integral of Ex is multiplied by <code class="docutils literal notranslate"><span class="pre">-1</span></code>.
As another example, we may require a line integral which is obtained by first taking surface integral
over a surface of height h and width w and then dividing by the width.
In this case, we may specify the value of these parameters as <code class="docutils literal notranslate"><span class="pre">1./w</span> <span class="pre">1./w,</span> <span class="pre">1./w</span></code>. Note that this can only be done
for a uniform grid simulation.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">RawBFieldReduction</span></code></dt><dd><p>This type is ONLY for the B-field at their respective staggering on the Yee-grid (or the type of grid used in the
simulation) and executes the <code class="docutils literal notranslate"><span class="pre">reduced_function</span></code> which is a user-defined analytic function as given below.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduced_function(x,y,z)</span></code> (<cite>string</cite>)</dt><dd><p>An analytic function used to select the region over which the B-fields will be reduced using
the <code class="docutils literal notranslate"><span class="pre">reduction_type</span></code> described below.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduction_type</span></code> (<cite>string</cite>)</dt><dd><p>The type of reduction to be performed. It must be either <code class="docutils literal notranslate"><span class="pre">Maximum</span></code>, <code class="docutils literal notranslate"><span class="pre">Minimum</span></code> or
<code class="docutils literal notranslate"><span class="pre">Integral</span></code>.
<code class="docutils literal notranslate"><span class="pre">Integral</span></code> computes the spatial surface or volume integral, depending on the choice
of the <code class="docutils literal notranslate"><span class="pre">integration_type</span></code>, of the function defined in the parser by summing its value on
all grid points and multiplying the result by the area or volume of a cell.
Please be also aware that measuring maximum quantities might be very noisy in PIC
simulations.</p>
</dd>
</dl>
</li>
</ul>
<p>The output columns correspond to the timestep counter, physical time, and reduced values of Bx, By, Bz components.</p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.integration_type</span></code> (<cite>string</cite>)</dt><dd><p>The type of integration to be performed. It must be either <code class="docutils literal notranslate"><span class="pre">surface</span></code> or <code class="docutils literal notranslate"><span class="pre">volume</span></code>.
Note that the surface integral provides the integrated normal as well as the
traverse fields over the surface. For the surface integral, the user-defined parser
for the plane should be less than one cell size in thickness in the direction of the surface normal.
Also, if the surface to be defined has an edge that overlaps with the domain boundary but the edge parallel
to it does not overlap with the domain boundary, e.g. a half cross-section of a plane, then exclude the
edge that overlaps with the domain boundary while defining the surface.</p>
<p>For example, we can define a surface on a y-plane at a location, <cite>y_plane_location</cite>, having a half cross-section
from z=-Lz/2 to 0, where Lz is the length of the domain in the z-direction spanning from -Lz/2 to Lz/2, as follows:</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.reduced_function(x,y,z)</span> <span class="pre">=</span> <span class="pre">&quot;</span> <span class="pre">(y</span> <span class="pre">&gt;</span> <span class="pre">y_plane_location</span> <span class="pre">-</span> <span class="pre">dy/2.</span> <span class="pre">-</span> <span class="pre">epsilon)</span> <span class="pre">*</span> <span class="pre">(y</span> <span class="pre">&lt;</span> <span class="pre">y_plane_location</span> <span class="pre">+</span> <span class="pre">epsilon)</span> <span class="pre">*</span> <span class="pre">(z</span> <span class="pre">&gt;</span> <span class="pre">-Lz/2.)</span> <span class="pre">*</span> <span class="pre">(z</span> <span class="pre">&lt;</span> <span class="pre">0.</span> <span class="pre">+</span> <span class="pre">epsilon)</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">&quot;</span></code></p>
<p>In this example, epsilon is a very small number which is larger than machine precision.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.surface_normal</span></code> (<cite>string</cite>)</dt><dd><p>This parameter is only required when the <code class="docutils literal notranslate"><span class="pre">integration_type</span></code> is <code class="docutils literal notranslate"><span class="pre">surface</span></code>.
It specifies the surface on which the surface integration is required, which must be either <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> or <code class="docutils literal notranslate"><span class="pre">z</span></code>.
The direction of the normal is positive in the Cartesian directions.
in the negative direction.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.scaling_factor</span></code> (<cite>string</cite>)  optional (default <cite>1 1 1</cite>)</dt><dd><p>This parameter is used when the <code class="docutils literal notranslate"><span class="pre">integration_type</span></code> is set to <code class="docutils literal notranslate"><span class="pre">surface</span></code>. The parser takes three values to scale
the reduced field quantities, namely, the surface integral of Bx, By, and Bz.
This parameter can be used in the following two scenarios:
Let’s say, we require the surface integral of Bx on a surface, with the surface normal in the negative x direction.
In this case, we would specify the value of this parameter as <code class="docutils literal notranslate"><span class="pre">-1.</span> <span class="pre">1.</span> <span class="pre">1.</span></code> so that the surface integral of Bx is multiplied by <code class="docutils literal notranslate"><span class="pre">-1</span></code>.
As another example, we may require surface integral of H-field, which can be obtained by dividing the surface integrals of Bx, By, and Bz
by permeability, <code class="docutils literal notranslate"><span class="pre">mu</span></code>, if <code class="docutils literal notranslate"><span class="pre">mu</span></code> is constant. In this case, we would specify the value of this parameter as <code class="docutils literal notranslate"><span class="pre">1./mu,</span>&#160;&#160;&#160; <span class="pre">1./mu,</span> <span class="pre">1./mu</span></code>.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ParticleNumber</span></code></dt><dd><p>This type computes the total number of macroparticles and of physical particles (i.e. the
sum of their weights) in the whole simulation domain (for each species and summed over all
species). It can be useful in particular for simulations with creation (ionization, QED
processes) or removal (resampling) of particles.</p>
<p>The output columns are
total number of macroparticles summed over all species,
total number of macroparticles of each species,
sum of the particles’ weight summed over all species,
sum of the particles’ weight of each species.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">BeamRelevant</span></code></dt><dd><p>This type computes properties of a particle beam relevant for particle accelerators, like position, momentum, emittance, etc.</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.species</span></code> must be provided, such that the diagnostics are done for this (beam-like) species only.</p>
<p>The output columns (for 3D-XYZ) are the following, where the average is done over the whole species (typical usage: the particle beam is in a separate species):</p>
<p>[0]: simulation step (iteration).</p>
<p>[1]: time (s).</p>
<p>[2], [3], [4]: The mean values of beam positions (m)
<span class="math notranslate nohighlight">\(\langle x \rangle\)</span>,
<span class="math notranslate nohighlight">\(\langle y \rangle\)</span>,
<span class="math notranslate nohighlight">\(\langle z \rangle\)</span>.</p>
<p>[5], [6], [7]: The mean values of beam relativistic momenta (kg m/s)
<span class="math notranslate nohighlight">\(\langle p_x \rangle\)</span>,
<span class="math notranslate nohighlight">\(\langle p_y \rangle\)</span>,
<span class="math notranslate nohighlight">\(\langle p_z \rangle\)</span>.</p>
<p>[8]: The mean Lorentz factor <span class="math notranslate nohighlight">\(\langle \gamma \rangle\)</span>.</p>
<p>[9], [10], [11]: The RMS values of beam positions (m)
<span class="math notranslate nohighlight">\(\delta_x = \sqrt{ \langle (x - \langle x \rangle)^2 \rangle }\)</span>,
<span class="math notranslate nohighlight">\(\delta_y = \sqrt{ \langle (y - \langle y \rangle)^2 \rangle }\)</span>,
<span class="math notranslate nohighlight">\(\delta_z = \sqrt{ \langle (z - \langle z \rangle)^2 \rangle }\)</span>.</p>
<p>[12], [13], [14]: The RMS values of beam relativistic momenta (kg m/s)
<span class="math notranslate nohighlight">\(\delta_{px} = \sqrt{ \langle (p_x - \langle p_x \rangle)^2 \rangle }\)</span>,
<span class="math notranslate nohighlight">\(\delta_{py} = \sqrt{ \langle (p_y - \langle p_y \rangle)^2 \rangle }\)</span>,
<span class="math notranslate nohighlight">\(\delta_{pz} = \sqrt{ \langle (p_z - \langle p_z \rangle)^2 \rangle }\)</span>.</p>
<p>[15]: The RMS value of the Lorentz factor
<span class="math notranslate nohighlight">\(\sqrt{ \langle (\gamma - \langle \gamma \rangle)^2 \rangle }\)</span>.</p>
<p>[16], [17], [18]: beam projected transverse RMS normalized emittance (m)
<span class="math notranslate nohighlight">\(\epsilon_x = \dfrac{1}{mc} \sqrt{\delta_x^2 \delta_{px}^2 -
\Big\langle (x-\langle x \rangle) (p_x-\langle p_x \rangle) \Big\rangle^2}\)</span>,
<span class="math notranslate nohighlight">\(\epsilon_y = \dfrac{1}{mc} \sqrt{\delta_y^2 \delta_{py}^2 -
\Big\langle (y-\langle y \rangle) (p_y-\langle p_y \rangle) \Big\rangle^2}\)</span>,
<span class="math notranslate nohighlight">\(\epsilon_z = \dfrac{1}{mc} \sqrt{\delta_z^2 \delta_{pz}^2 -
\Big\langle (z-\langle z \rangle) (p_z-\langle p_z \rangle) \Big\rangle^2}\)</span>.</p>
<p>[19], [20]: beta function for the transverse directions (m)
<span class="math notranslate nohighlight">\(\beta_x = \dfrac{{\delta_x}^2}{\epsilon_x}\)</span>,
<span class="math notranslate nohighlight">\(\beta_y = \dfrac{{\delta_y}^2}{\epsilon_y}\)</span>.</p>
<p>[21]: The charge of the beam (C).</p>
<p>For 2D-XZ,
<span class="math notranslate nohighlight">\(\langle y \rangle\)</span>,
<span class="math notranslate nohighlight">\(\delta_y\)</span>, and
<span class="math notranslate nohighlight">\(\epsilon_y\)</span> will not be outputted.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">LoadBalanceCosts</span></code></dt><dd><p>This type computes the cost, used in load balancing, for each box on the domain.
The cost <span class="math notranslate nohighlight">\(c\)</span> is computed as</p>
<div class="math notranslate nohighlight">
\[c = n_{\text{particle}} \cdot w_{\text{particle}} + n_{\text{cell}} \cdot w_{\text{cell}},\]</div>
<p>where
<span class="math notranslate nohighlight">\(n_{\text{particle}}\)</span> is the number of particles on the box,
<span class="math notranslate nohighlight">\(w_{\text{particle}}\)</span> is the particle cost weight factor (controlled by <code class="docutils literal notranslate"><span class="pre">algo.costs_heuristic_particles_wt</span></code>),
<span class="math notranslate nohighlight">\(n_{\text{cell}}\)</span> is the number of cells on the box, and
<span class="math notranslate nohighlight">\(w_{\text{cell}}\)</span> is the cell cost weight factor (controlled by <code class="docutils literal notranslate"><span class="pre">algo.costs_heuristic_cells_wt</span></code>).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">LoadBalanceEfficiency</span></code></dt><dd><p>This type computes the load balance efficiency, given the present costs
and distribution mapping. Load balance efficiency is computed as the
mean cost over all ranks, divided by the maximum cost over all ranks.
Until costs are recorded, load balance efficiency is output as <cite>-1</cite>;
at earliest, the load balance efficiency can be output starting at step
<cite>2</cite>, since costs are not recorded until step <cite>1</cite>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ParticleHistogram</span></code></dt><dd><p>This type computes a user defined particle histogram.</p>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.species</span></code> (<cite>string</cite>)</dt><dd><p>A species name must be provided,
such that the diagnostics are done for this species.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.histogram_function(t,x,y,z,ux,uy,uz)</span></code> (<cite>string</cite>)</dt><dd><p>A histogram function must be provided.
<cite>t</cite> represents the physical time in seconds during the simulation.
<cite>x, y, z</cite> represent particle positions in the unit of meter.
<cite>ux, uy, uz</cite> represent the particle velocities in the unit of
<span class="math notranslate nohighlight">\(\gamma v/c\)</span>, where
<span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor,
<span class="math notranslate nohighlight">\(v/c\)</span> is the particle velocity normalized by the speed of light.
E.g.
<code class="docutils literal notranslate"><span class="pre">x</span></code> produces the position (density) distribution in <cite>x</cite>.
<code class="docutils literal notranslate"><span class="pre">ux</span></code> produces the velocity distribution in <cite>x</cite>,
<code class="docutils literal notranslate"><span class="pre">sqrt(ux*ux+uy*uy+uz*uz)</span></code> produces the speed distribution.
The default value of the histogram without normalization is
<span class="math notranslate nohighlight">\(f = \sum\limits_{i=1}^N w_i\)</span>, where
<span class="math notranslate nohighlight">\(\sum\limits_{i=1}^N\)</span> is the sum over <span class="math notranslate nohighlight">\(N\)</span> particles
in that bin,
<span class="math notranslate nohighlight">\(w_i\)</span> denotes the weight of the ith particle.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.bin_number</span></code> (<cite>int</cite> &gt; 0)</dt><dd><p>This is the number of bins used for the histogram.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.bin_max</span></code> (<cite>float</cite>)</dt><dd><p>This is the maximum value of the bins.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.bin_min</span></code> (<cite>float</cite>)</dt><dd><p>This is the minimum value of the bins.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.normalization</span></code> (optional)</dt><dd><p>This provides options to normalize the histogram:</p>
<p><code class="docutils literal notranslate"><span class="pre">unity_particle_weight</span></code>
uses unity particle weight to compute the histogram,
such that the values of the histogram are
the number of counted macroparticles in that bin,
i.e.  <span class="math notranslate nohighlight">\(f = \sum\limits_{i=1}^N 1\)</span>,
<span class="math notranslate nohighlight">\(N\)</span> is the number of particles in that bin.</p>
<p><code class="docutils literal notranslate"><span class="pre">max_to_unity</span></code> will normalize the histogram such that
its maximum value is one.</p>
<p><code class="docutils literal notranslate"><span class="pre">area_to_unity</span></code> will normalize the histogram such that
the area under the histogram is one,
so the histogram is also the probability density function.</p>
<p>If nothing is provided,
the macroparticle weight will be used to compute
the histogram, and no normalization will be done.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.filter_function(t,x,y,z,ux,uy,uz)</span></code> (<cite>string</cite>) optional</dt><dd><p>Users can provide an expression returning a boolean for whether a particle is taken
into account when calculating the histogram.
<cite>t</cite> represents the physical time in seconds during the simulation.
<cite>x, y, z</cite> represent particle positions in the unit of meter.
<cite>ux, uy, uz</cite> represent particle velocities in the unit of
<span class="math notranslate nohighlight">\(\gamma v/c\)</span>, where
<span class="math notranslate nohighlight">\(\gamma\)</span> is the Lorentz factor,
<span class="math notranslate nohighlight">\(v/c\)</span> is the particle velocity normalized by the speed of light.
E.g. If provided <cite>(x&gt;0.0)*(uz&lt;10.0)</cite> only those particles located at
positions <cite>x</cite> greater than <cite>0</cite>, and those having velocity <cite>uz</cite> less than 10,
will be taken into account when calculating the histogram.</p>
</dd>
</dl>
</li>
</ul>
<p>The output columns are
values of the 1st bin, the 2nd bin, …, the nth bin.
An example input file and a loading python script of
using the histogram reduced diagnostics
are given in <code class="docutils literal notranslate"><span class="pre">Examples/Tests/initial_distribution/</span></code>.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ParticleExtrema</span></code></dt><dd><p>This type computes the minimum and maximum values of
particle position, momentum, gamma, weight,
and the <span class="math notranslate nohighlight">\(\chi\)</span> parameter for QED species.</p>
<p><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.species</span></code> must be provided,
such that the diagnostics are done for this species only.</p>
<p>The output columns are
minimum and maximum position <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span>, <span class="math notranslate nohighlight">\(z\)</span>;
minimum and maximum momentum <span class="math notranslate nohighlight">\(p_x\)</span>, <span class="math notranslate nohighlight">\(p_y\)</span>, <span class="math notranslate nohighlight">\(p_z\)</span>;
minimum and maximum gamma <span class="math notranslate nohighlight">\(\gamma\)</span>;
minimum and maximum weight <span class="math notranslate nohighlight">\(w\)</span>;
minimum and maximum <span class="math notranslate nohighlight">\(\chi\)</span>.</p>
<p>Note that when the QED parameter <span class="math notranslate nohighlight">\(\chi\)</span> is computed,
field gather is carried out at every output,
so the time of the diagnostic may be long
depending on the simulation size.</p>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">ChargeOnEB</span></code></dt><dd><p>This type computes the total surface charge on the embedded boundary
(in Coulombs), by using the formula</p>
<div class="math notranslate nohighlight">
\[Q_{tot} = \epsilon_0 \iint dS \cdot E\]</div>
<p>where the integral is performed over the surface of the embedded boundary.</p>
<p>When providing <code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.weighting_function(x,y,z)</span></code>, the
computed integral is weighted:
.. math:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="n">epsilon_0</span><span class="w"> </span><span class="err">\</span><span class="n">iint</span><span class="w"> </span><span class="n">dS</span><span class="w"> </span><span class="err">\</span><span class="n">cdot</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="err">\</span><span class="n">times</span><span class="w"> </span><span class="n">weighting</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>In particular, by choosing a weighting function which returns either
1 or 0, it is possible to compute the charge on only some part of the
embedded boundary.</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.intervals</span></code> (<cite>string</cite>)</dt><dd><p>Using the <a class="reference internal" href="#intervals-parser">Intervals Parser</a> syntax, this string defines the timesteps at which reduced
diagnostics are written to file.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.path</span></code> (<cite>string</cite>) optional (default <cite>./diags/reducedfiles/</cite>)</dt><dd><p>The path that the output file will be stored.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.extension</span></code> (<cite>string</cite>) optional (default <cite>txt</cite>)</dt><dd><p>The extension of the output file.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">&lt;reduced_diags_name&gt;.separator</span></code> (<cite>string</cite>) optional (default a <cite>whitespace</cite>)</dt><dd><p>The separator between row values in the output file.
The default separator is a whitespace.</p>
</dd>
</dl>
</li>
</ul>
</section>
</section>
<section id="lookup-tables-and-other-settings-for-qed-modules">
<h2>Lookup tables and other settings for QED modules<a class="headerlink" href="#lookup-tables-and-other-settings-for-qed-modules" title="Link to this heading"></a></h2>
<p>Lookup tables store pre-computed values for functions used by the QED modules.
<strong>This feature requires to compile with QED=TRUE (and also with QED_TABLE_GEN=TRUE for table generation)</strong></p>
<ul>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">qed_bw.lookup_table_mode</span></code> (<cite>string</cite>)</dt><dd><p>There are three options to prepare the lookup table required by the Breit-Wheeler module:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">builtin</span></code>:  a built-in table is used (Warning: the table gives reasonable results but its resolution is quite low).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generate</span></code>: a new table is generated. This option requires Boost math library
(version &gt;= 1.66) and to compile with <code class="docutils literal notranslate"><span class="pre">QED_TABLE_GEN=TRUE</span></code>. All
the following parameters must be specified (table 1 is used to evolve the optical depth
of the photons, while table 2 is used for pair generation):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_dndt_chi_min</span></code> (<cite>float</cite>): minimum chi parameter for lookup table 1 (
used for the evolution of the optical depth of the photons)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_dndt_chi_max</span></code> (<cite>float</cite>): maximum chi parameter for lookup table 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_dndt_how_many</span></code> (<cite>int</cite>): number of points to be used for lookup table 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_pair_chi_min</span></code> (<cite>float</cite>): minimum chi parameter for lookup table 2 (
used for pair generation)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_pair_chi_max</span></code> (<cite>float</cite>): maximum chi parameter for lookup table 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_pair_chi_how_many</span></code> (<cite>int</cite>): number of points to be used for chi axis in lookup table 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.tab_pair_frac_how_many</span></code> (<cite>int</cite>): number of points to be used for the second axis in lookup table 2
(the second axis is the ratio between the quantum parameter of the less energetic particle of the pair and the
quantum parameter of the photon).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.save_table_in</span></code> (<cite>string</cite>): where to save the lookup table</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">load</span></code>: a lookup table is loaded from a pre-generated binary file. The following parameter
must be specified:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qed_bw.load_table_from</span></code> (<cite>string</cite>): name of the lookup table file to read from.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt><code class="docutils literal notranslate"><span class="pre">qed_qs.lookup_table_mode</span></code> (<cite>string</cite>)</dt><dd><p>There are three options to prepare the lookup table required by the Quantum Synchrotron module:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">builtin</span></code>: a built-in table is used (Warning: the table gives reasonable results but its resolution is quite low).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">generate</span></code>: a new table is generated. This option requires Boost math library
(version &gt;= 1.66) and to compile with <code class="docutils literal notranslate"><span class="pre">QED_TABLE_GEN=TRUE</span></code>. All
the following parameters must be specified (table 1 is used to evolve the optical depth
of the particles, while table 2 is used for photon emission):</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_dndt_chi_min</span></code> (<cite>float</cite>): minimum chi parameter for lookup table 1 (
used for the evolution of the optical depth of electrons and positrons)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_dndt_chi_max</span></code> (<cite>float</cite>): maximum chi parameter for lookup table 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_dndt_how_many</span></code> (<cite>int</cite>): number of points to be used for lookup table 1</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_em_chi_min</span></code> (<cite>float</cite>): minimum chi parameter for lookup table 2 (
used for photon emission)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_em_chi_max</span></code> (<cite>float</cite>): maximum chi parameter for lookup table 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_em_chi_how_many</span></code> (<cite>int</cite>): number of points to be used for chi axis in lookup table 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_em_frac_how_many</span></code> (<cite>int</cite>): number of points to be used for the second axis in lookup table 2
(the second axis is the ratio between the quantum parameter of the photon and the
quantum parameter of the charged particle).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.tab_em_frac_min</span></code> (<cite>float</cite>): minimum value to be considered for the second axis of lookup table 2</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.save_table_in</span></code> (<cite>string</cite>): where to save the lookup table</p></li>
</ul>
</div></blockquote>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">load</span></code>: a lookup table is loaded from a pre-generated binary file. The following parameter
must be specified:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qed_qs.load_table_from</span></code> (<cite>string</cite>): name of the lookup table file to read from.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_bw.chi_min</span></code> (<cite>float</cite>): minimum chi parameter to be considered by the Breit-Wheeler engine</dt><dd><p>(suggested value : 0.01)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_qs.chi_min</span></code> (<cite>float</cite>): minimum chi parameter to be considered by the Quantum Synchrotron engine</dt><dd><p>(suggested value : 0.001)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_qs.photon_creation_energy_threshold</span></code> (<cite>float</cite>) optional (default <cite>2</cite>)</dt><dd><p>Energy threshold for photon particle creation in <cite>*me*c^2</cite> units.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.do_qed_schwinger</span></code> (<cite>bool</cite>) optional (default <cite>0</cite>)</dt><dd><p>If this is 1, Schwinger electron-positron pairs can be generated in vacuum in the cells where the EM field is high enough.
Activating the Schwinger process requires the code to be compiled with <code class="docutils literal notranslate"><span class="pre">QED=TRUE</span></code> and <code class="docutils literal notranslate"><span class="pre">PICSAR</span></code>.
If <code class="docutils literal notranslate"><span class="pre">warpx.do_qed_schwinger</span> <span class="pre">=</span> <span class="pre">1</span></code>, Schwinger product species must be specified with
<code class="docutils literal notranslate"><span class="pre">qed_schwinger.ele_product_species</span></code> and <code class="docutils literal notranslate"><span class="pre">qed_schwinger.pos_product_species</span></code>.
Schwinger process requires either <code class="docutils literal notranslate"><span class="pre">warpx.grid_type</span> <span class="pre">=</span> <span class="pre">collocated</span></code> or
<code class="docutils literal notranslate"><span class="pre">algo.field_gathering=momentum-conserving</span></code> (so that different field components are computed
at the same location in the grid) and does not currently support mesh refinement, cylindrical
coordinates or single precision.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_schwinger.ele_product_species</span></code> (<cite>string</cite>)</dt><dd><p>If Schwinger process is activated, an electron product species must be specified
(the name of an existing electron species must be provided).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_schwinger.pos_product_species</span></code> (<cite>string</cite>)</dt><dd><p>If Schwinger process is activated, a positron product species must be specified
(the name of an existing positron species must be provided).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_schwinger.y_size</span></code> (<cite>float</cite>; in meters)</dt><dd><p>If Schwinger process is activated with <code class="docutils literal notranslate"><span class="pre">DIM=2D</span></code>, a transverse size must be specified.
It is used to convert the pair production rate per unit volume into an actual number of created particles.
This value should correspond to the typical transverse extent for which the EM field has a very high value
(e.g. the beam waist for a focused laser beam).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_schwinger.xmin,ymin,zmin</span></code> and <code class="docutils literal notranslate"><span class="pre">qed_schwinger.xmax,ymax,zmax</span></code> (<cite>float</cite>) optional (default unlimited)</dt><dd><p>When <code class="docutils literal notranslate"><span class="pre">qed_schwinger.xmin</span></code> and <code class="docutils literal notranslate"><span class="pre">qed_schwinger.xmax</span></code> are set, they delimit the region within
which Schwinger pairs can be created.
The same is applicable in the other directions.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">qed_schwinger.threshold_poisson_gaussian</span></code> (<cite>integer</cite>) optional (default <cite>25</cite>)</dt><dd><p>If the expected number of physical pairs created in a cell at a given timestep is smaller than this threshold,
a Poisson distribution is used to draw the actual number of physical pairs created.
Otherwise a Gaussian distribution is used.
Note that, regardless of this parameter, the number of macroparticles created is at most one per cell
per timestep per species (with a weight corresponding to the number of physical pairs created).</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="checkpoints-and-restart">
<h2>Checkpoints and restart<a class="headerlink" href="#checkpoints-and-restart" title="Link to this heading"></a></h2>
<p>WarpX supports checkpoints/restart via AMReX.
The checkpoint capability can be turned with regular diagnostics: <code class="docutils literal notranslate"><span class="pre">&lt;diag_name&gt;.format</span> <span class="pre">=</span> <span class="pre">checkpoint</span></code>.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amr.restart</span></code> (<cite>string</cite>)</dt><dd><p>Name of the checkpoint file to restart from. Returns an error if the folder does not exist
or if it is not properly formatted.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="intervals-parser">
<h2>Intervals parser<a class="headerlink" href="#intervals-parser" title="Link to this heading"></a></h2>
<p>WarpX can parse time step interval expressions of the form <code class="docutils literal notranslate"><span class="pre">start:stop:period</span></code>, e.g.
<code class="docutils literal notranslate"><span class="pre">1:2:3,</span> <span class="pre">4::,</span> <span class="pre">5:6,</span> <span class="pre">:,</span> <span class="pre">::10</span></code>.
A comma is used as a separator between groups of intervals, which we call slices.
The resulting time steps are the <a class="reference external" href="https://en.wikipedia.org/wiki/Union_(set_theory)">union set</a> of all given slices.
White spaces are ignored.
A single slice can have 0, 1 or 2 colons <code class="docutils literal notranslate"><span class="pre">:</span></code>, just as <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.s_.html">numpy slices</a>, but with inclusive upper bound for <code class="docutils literal notranslate"><span class="pre">stop</span></code>.</p>
<ul class="simple">
<li><p>For 0 colon the given value is the period</p></li>
<li><p>For 1 colon the given string is of the type <code class="docutils literal notranslate"><span class="pre">start:stop</span></code></p></li>
<li><p>For 2 colons the given string is of the type <code class="docutils literal notranslate"><span class="pre">start:stop:period</span></code></p></li>
</ul>
<p>Any value that is not given is set to default.
Default is <code class="docutils literal notranslate"><span class="pre">0</span></code> for the start, <code class="docutils literal notranslate"><span class="pre">std::numeric_limits&lt;int&gt;::max()</span></code> for the stop and <code class="docutils literal notranslate"><span class="pre">1</span></code> for the
period.
For the 1 and 2 colon syntax, actually having values in the string is optional
(this means that <code class="docutils literal notranslate"><span class="pre">::5</span></code>, <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">::10</span></code> and <code class="docutils literal notranslate"><span class="pre">100</span> <span class="pre">:</span></code> are all valid syntaxes).</p>
<p>All values can be expressions that will be parsed in the same way as other integer input parameters.</p>
<p><strong>Examples</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">50</span></code> -&gt; do something at timesteps 0, 50, 100, 150, etc.
(equivalent to <code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">::50</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">300:600:100</span></code> -&gt; do something at timesteps 300, 400, 500 and 600.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">300::50</span></code> -&gt; do something at timesteps 300, 350, 400, 450, etc.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">105:108,205:208</span></code> -&gt; do something at timesteps 105, 106, 107, 108,
205, 206, 207 and 208. (equivalent to <code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">105</span> <span class="pre">:</span> <span class="pre">108</span> <span class="pre">:</span> <span class="pre">,</span> <span class="pre">205</span> <span class="pre">:</span> <span class="pre">208</span> <span class="pre">:</span></code>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">:</span></code> or  <code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">::</span></code> -&gt; do something at every timestep.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">167:167,253:253,275:425:50</span></code> do something at timesteps 167, 253, 275,
325, 375 and 425.</p></li>
</ul>
<p>This is essentially the python slicing syntax except that the stop is inclusive
(<code class="docutils literal notranslate"><span class="pre">0:100</span></code> contains 100) and that no colon means that the given value is the period.
Note that if a given period is zero or negative, the corresponding slice is disregarded.
For example, <code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">-1</span></code> deactivates <code class="docutils literal notranslate"><span class="pre">something</span></code> and
<code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">::-1,100:1000:25</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">something_intervals</span> <span class="pre">=</span> <span class="pre">100:1000:25</span></code>.</p>
</section>
<section id="solving-magnetization-using-llg-equation">
<h2>Solving magnetization using LLG equation<a class="headerlink" href="#solving-magnetization-using-llg-equation" title="Link to this heading"></a></h2>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.M_ext_grid_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the
magnetization of the material. The “default” style initializes the
magnetization (Mx,My,Mz) to (0.0, 0.0, 0.0).
The string can be set to “constant” if a constant magnetization is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">warpx.M_external_grid</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_M_ext_grid_function</span></code>, then a mathematical expression can
be used to initialize the magnetization on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Mx_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.My_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Mz_external_grid_function(x,y,z)</span></code> to initialize the
magnetization for each of the three components on the grid.
Constants required in the expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
For example, if <code class="docutils literal notranslate"><span class="pre">warpx.Mx_external_grid_function(x,y,z)=Mo*x</span> <span class="pre">+</span> <span class="pre">delta*(y</span> <span class="pre">+</span> <span class="pre">z)</span></code>
then the constants <cite>Mo</cite> and <cite>delta</cite> required in the above equation
can be set using <code class="docutils literal notranslate"><span class="pre">my_constants.Mo=</span></code> and <code class="docutils literal notranslate"><span class="pre">my_constants.delta=</span></code> in the
input file. For a two-dimensional simulation, it is assumed that the first dimension
is <cite>x</cite> and the second dimension in <cite>z</cite>, and the value of <cite>y</cite> is set to zero.
Note that the current implementation of the parser for M-field
does not work with RZ and the code will abort with an error message.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input parameter must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.H_bias_ext_grid_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the external magnetic DC
bias field applied to the material. The “default” style initializes the
magnetic DC bias (Hx_bias,Hy_bias,Hz_bias) to (0.0, 0.0, 0.0).
The string can be set to “constant” if a constant magnetic bias is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">warpx.H_bias_external_grid</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_H_bias_ext_grid_function</span></code>, then a mathematical expression can
be used to initialize the magnetic bias on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">warpx.Hx_bias_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hy_bias_external_grid_function(x,y,z)</span></code>,
<code class="docutils literal notranslate"><span class="pre">warpx.Hz_bias_external_grid_function(x,y,z)</span></code> to initialize the external
magnetic bias for each of the three components on the grid.
Constants required in the expression can be set using <code class="docutils literal notranslate"><span class="pre">my_constants</span></code>.
For example, if <code class="docutils literal notranslate"><span class="pre">warpx.Hx_bias_external_grid_function(x,y,z)=Ho_bias*x</span> <span class="pre">+</span> <span class="pre">delta*(y</span> <span class="pre">+</span> <span class="pre">z)</span></code>
then the constants <cite>Ho_bias</cite> and <cite>delta</cite> required in the above equation
can be set using <code class="docutils literal notranslate"><span class="pre">my_constants.Ho_bias=</span></code> and <code class="docutils literal notranslate"><span class="pre">my_constants.delta=</span></code> in the
input file. For a two-dimensional simulation, it is assumed that the first dimension
is <cite>x</cite> and the second dimension in <cite>z</cite>, and the value of <cite>y</cite> is set to zero.
Note that the current implementation of the parser for H_bias-field
does not work with RZ and the code will abort with an error message.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input parameter must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.M_external_grid</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">warpx.H_bias_external_grid</span></code> (list of <cite>double</cite>)</dt><dd><p>required when <code class="docutils literal notranslate"><span class="pre">warpx.M_ext_grid_init_style=&quot;constant&quot;</span></code>
and when <code class="docutils literal notranslate"><span class="pre">warpx.H_bias_ext_grid_init_style=&quot;constant&quot;</span></code>, respectively.
External uniform and constant magnetization and magnetostatic bias field added
to the grid at initialization. Use with caution as these fields are used for
the field solver. In particular, do not use any other boundary condition
than periodic.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_Ms_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the saturation magnetization
of the material. The “default” style initializes the saturation magnetization mag_Ms to 0.0.
The string can be set to “constant” if a constant saturation magnetization is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_Ms</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_mag_Ms_function</span></code>, then a mathematical expression can
be used to initialize the saturation magnetization on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">macroscopic.mag_Ms_function(x,y,z)</span></code> to initialize the saturation magnetization.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input property must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_exchange_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the coefficient of the exchange coupling term
of the material. The “default” style initializes the coefficient of the exchange coupling term mag_exchange to 0.0.
The string can be set to “constant” if a constant coefficient of the exchange coupling term is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_exchange</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_mag_exchange_function</span></code>, then a mathematical expression can
be used to initialize the coefficient of the exchange coupling term on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">macroscopic.mag_exchange_function(x,y,z)</span></code> to initialize the coefficient of the exchange coupling term.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input property must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_anisotropy_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the coefficient of the anisotropy coupling term
of the material. The “default” style initializes the coefficient of the anisotropy coupling term mag_anisotropy to 0.0.
The string can be set to “constant” if a constant coefficient of the anisotropy coupling term is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_anisotropy</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_mag_anisotropy_function</span></code>, then a mathematical expression can
be used to initialize the coefficient of the anisotropy coupling term on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">macroscopic.mag_anisotropy_function(x,y,z)</span></code> to initialize the coefficient of the anisotropy coupling term.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input property must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_alpha_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the Gilbert damping factor
of the material. The “default” style initializes the Gilbert damping factor <code class="docutils literal notranslate"><span class="pre">mag_alpha</span></code> to 0.0.
Note that only positive values for Gilbert damping factor <code class="docutils literal notranslate"><span class="pre">mag_alpha</span></code> are allowed in the simulation.
The string can be set to “constant” if a constant Gilbert damping factor is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_alpha</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_mag_alpha_function</span></code>, then a mathematical expression can
be used to initialize the Gilbert damping factor on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">macroscopic.mag_alpha_function(x,y,z)</span></code> to initialize the Gilbert damping factor.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input property must be provided.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">macroscopic.mag_gamma_init_style</span></code> (string) optional (default is “default”)</dt><dd><p>This parameter determines the type of initialization for the gyromagnetic ratio
of the material. The “default” style initializes the gyromagnetic ratio mag_gamma to 0.0.
Note that only negative values for gyromagnetic ratio <code class="docutils literal notranslate"><span class="pre">mag_gamma</span></code> are allowed in the simulations and positive values for <code class="docutils literal notranslate"><span class="pre">mag_alpha</span></code> are allowed.
The value of <code class="docutils literal notranslate"><span class="pre">mag_gamma</span></code> depends on the type of spins under consideration. For electrons, <code class="docutils literal notranslate"><span class="pre">mag_gamma</span></code> is a constant value -1.759e11 Coulomb/kilogram.
The string can be set to “constant” if a constant gyromagnetic ratio is
required to be set at initialization. If set to “constant”, then an
additional parameter, namely, <code class="docutils literal notranslate"><span class="pre">macroscopic.mag_gamma</span></code> must be specified.
If set to <code class="docutils literal notranslate"><span class="pre">parse_mag_gamma_function</span></code>, then a mathematical expression can
be used to initialize the gyromagnetic ratio on the grid. It
requires additional parameters in the input file, namely,
<code class="docutils literal notranslate"><span class="pre">macroscopic.mag_gamma_function(x,y,z)</span></code> to initialize the gyromagnetic ratio.
If <code class="docutils literal notranslate"><span class="pre">algo.em_solver_medium</span></code> is set to macroscopic, and <code class="docutils literal notranslate"><span class="pre">USE_LLG</span> <span class="pre">=</span> <span class="pre">TRUE</span></code>,
then this input property must be provided.</p>
</dd>
</dl>
</li>
</ul>
</section>
<section id="testing-and-debugging">
<span id="running-cpp-parameters-test-debug"></span><h2>Testing and Debugging<a class="headerlink" href="#testing-and-debugging" title="Link to this heading"></a></h2>
<p>When developing, testing and <a class="reference internal" href="workflows/debugging.html#debugging-warpx"><span class="std std-ref">debugging WarpX</span></a>, the following options can be considered.</p>
<ul class="simple">
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.verbose</span></code> (<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>; default is <code class="docutils literal notranslate"><span class="pre">1</span></code> for true)</dt><dd><p>Controls how much information is printed to the terminal, when running WarpX.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.always_warn_immediately</span></code> (<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>; default is <code class="docutils literal notranslate"><span class="pre">0</span></code> for false)</dt><dd><p>If set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, WarpX immediately prints every warning message as soon as
it is generated. It is mainly intended for debug purposes, in case a simulation
crashes before a global warning report can be printed.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.abort_on_warning_threshold</span></code> (string: <code class="docutils literal notranslate"><span class="pre">low</span></code>, <code class="docutils literal notranslate"><span class="pre">medium</span></code> or <code class="docutils literal notranslate"><span class="pre">high</span></code>) optional</dt><dd><p>Optional threshold to abort as soon as a warning is raised.
If the threshold is set, warning messages with priority greater than or
equal to the threshold trigger an immediate abort.
It is mainly intended for debug purposes, and is best used with
<code class="docutils literal notranslate"><span class="pre">warpx.always_warn_immediately=1</span></code>.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amrex.abort_on_unused_inputs</span></code> (<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>; default is <code class="docutils literal notranslate"><span class="pre">0</span></code> for false)</dt><dd><p>When set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, this option causes simulation to fail <em>after</em> its completion if there were unused parameters.
It is mainly intended for continuous integration and automated testing to check that all tests and inputs are adapted to API changes.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">amrex.use_profiler_syncs</span></code> (<code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>; default is <code class="docutils literal notranslate"><span class="pre">0</span></code> for false)</dt><dd><p>Adds a synchronization at the start of communication, so any load balance will be caught there (the timer is called <code class="docutils literal notranslate"><span class="pre">SyncBeforeComms</span></code>), then the comm operation will run.
This will slow down the run.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.serialize_initial_conditions</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Serialize the initial conditions for reproducible testing, e.g, in our continuous integration tests.
Mainly whether or not to use OpenMP threading for particle initialization.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">warpx.safe_guard_cells</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Run in safe mode, exchanging more guard cells, and more often in the PIC loop (for debugging).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">ablastr.fillboundary_always_sync</span></code> (<cite>0</cite> or <cite>1</cite>) optional (default <cite>0</cite>)</dt><dd><p>Run all <code class="docutils literal notranslate"><span class="pre">FillBoundary</span></code> operations on <code class="docutils literal notranslate"><span class="pre">MultiFab</span></code> to force-synchronize shared nodal points.
This slightly increases communication cost and can help to spot missing <code class="docutils literal notranslate"><span class="pre">nodal_sync</span></code> flags in these operations.</p>
</dd>
</dl>
</li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="domain_decomposition.html" class="btn btn-neutral float-left" title="Domain Decomposition" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="python.html" class="btn btn-neutral float-right" title="Python (PICMI)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2017-2024, MicroEleX collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>